\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename emms.info
@settitle The Emms Manual
@c %**end of header

@c History: The Emms manual was almost entirely rewritten for the
@c release of Emms version 2.


@dircategory Emacs
@direntry
* Emms: (emms).           The Emacs Multimedia System
@end direntry

@copying
 @copyright{} 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2014,
   2015, 2016, 2020, 2021, 2022, 2023, 2024, 2025 Free Software Foundation,
   Inc.
@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A
copy of the license is included in the section entitled "GNU Free
Documentation License".
@end quotation
@end copying

@c For printed material
@titlepage
@title The Emms Manual

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents
@c END For printed material

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Emms Manual

This is the Manual for the Emacs Multimedia System.

@insertcopying

@menu
Starting out
* Introduction::        Introduction to Emms.
* Quickstart Guide::    First steps with Emms for new users.
* Installation::        How to install Emms on your System.
* Setup::               How to setup Emms.
* Configuration::       More detailed setup and configuration.
* Getting Help::        Where to get help with Emms and make suggestions.
* Formats and Freedom:: File formats without restrictions.

Emms basics
* Basic Commands::      How to control Emms with ease.
* The Core File::       The inner core of Emms.
* Sources::             Sources for playlists-creation.
* Simple Players::      Some simple players.
* Playlists::           How Emms organizes media.

Advanced Features
* Track Information::        More narrative track descriptions.
* Interactive Playlists::    Interactive Playlists.
* Markable Playlists::       Allow tracks to be marked.
* Extending Emms::       How to define new players and modules.

Modules and Extensions
* The Browser::          Advanced metadata browsing.
* The Filter System::    Advanced metadata filtering.
* Sorting Playlists::    Sorting the order of the tracks.
* Persistent Playlists:: Restoring playlists on emacs startup.
* Editing Tracks::       Editing track information from within Emms.
* Emms Mode Line::       Emms information on the mode line.
* Limiting::             Derive a new playlist from the current.
* Music Player Daemon::  Interface to Music Player Daemon.
* Lyrics::               Displaying lyrics synchronously.
* Volume::               Changing the volume.
* Streaming Audio::      Interface to streaming audio.
* Radio Browser::        Search for internet radio stations
* APE / FLAC Commands::  How to play next or previous track in these files.
* Bookmarks::            Saving a place in a media file.
* Managing Playlists::   Managing multiple playlists.
* GNU FM::               Connect to music community websites.
* Listenbrainz::         Notify listenbrainz of tracks played.
* D-Bus::                Control Emms over D-Bus.

Copying and license
* Copying::             The GNU General Public License gives you permission to
                            redistribute Emms on certain terms; it also explains
                            that there is no warranty.
* The GNU FDL::         The license for this documentation.

Indices
* Concept Index::
* Function Index::
* Variable Index::
* Keybinding Index::

@detailmenu
--- The Detailed Node Listing ---

Here are some other nodes which are really inferiors of the ones
already listed, mentioned here so you can get to them in one step:

Installation
* Compiling Emms::      Compiling Emms into Byte-Code.

The Core File
* User Variables::     Variables for the user to tweak.
* Hooks::              Hooks for important Emms functions.
* Core Functions::     Providing the basic functionality of Emms.

Track Information
* Metadata Utilities:: Supported external metadata utilities.
* Defining Info Methods::    Defining new info methods.

Extending Emms
* New Player::               How to define a new player.
* Simple Player for `play':: Example player using @command{play}.
* More Complex Player::      Example of a complex player using @command{mpg321}.
@end detailmenu
@end menu

@end ifnottex

@c -------------------------------------------------------------------
@node Introduction
@chapter Introduction

@cindex introduction

Emms is the Emacs Multi-Media System. Emms organizes playlists, allows
browsing through track and album metadata, and plays files by calling
external players.

This manual tries to be the definitive source of information about
Emms, an online version of the manual is available at:
@uref{http://www.gnu.org/software/emms/manual/}.

The basic functionality of Emms consists of three parts: The core, the
sources, and the players.

The core resides in @file{emms.el}, provides a simple playlist, and
the basic functionality to use all the other features of Emms. It
provides the common user commands and interfaces for other parts. It
thinks in tracks, where a track is the combination of a type and a
name - e.g.  the track type 'file has a name that is the file
name. Other track types are possible.

To get to tracks, the core needs sources. The file @file{emms-source-file.el}
provides simple sources to interact with the file system.

When Emms finally has the sources in the playlist, it needs a player
to play them. @file{emms-player-simple.el} defines a few useful
players and provides a straightforward way of providing your own.

The Emms comes with many additional features to extend the
functionality beyond the core.

The way Emms works is easy to customize with your own code or by using
`M-x customize' or by changing the variables directly.


@c -------------------------------------------------------------------
@node Quickstart Guide
@chapter Quickstart Guide

This chapter demonstrates how to setup Emms so that you can start
listening to your music without having to read all of the
documentation first. This is the tl;dr version of the manual.

The first thing to do is to load Emms via GNU ELPA. Invoke @kbd{M-x
list-packages} and choose to install Emms.

If you are installing Emms manually, then start by telling Emacs where
your copy of Emms is located. Let's say you have it in
@file{~/elisp/emms/}. So add this line to your @file{.emacs}:

@lisp
(add-to-list 'load-path "~/elisp/emms/lisp/")
(require 'emms-setup)
@end lisp

(More detailed information about installing Emms can be found in the
installation chapter, @xref{Installation}.)

Either way, you are now ready to configure Emms. Your Emms config can
be as simple as three lines. For example:

@lisp
(emms-all)
(setq emms-player-list '(emms-player-vlc)
      emms-info-functions '(emms-info-native))
@end lisp

The function @code{emms-all} loads all of the stable features in Emms.

Emms can automatically generate that `setq' statement for you based on
which players and metadata readers you have installed on your
system. Just invoke @code{emms-setup-discover} and answer a few
questions.

The variable @var{emms-player-list} is a list of players that Emms
should call to play your media. In this example we assume that you
have VLC installed on your system. But if you use mpv or mplayer
instead, just change @code{emms-player-vlc} to @code{emms-player-mpv}
or @code{emms-player-mplayer}; you get the idea.

The variable @var{emms-info-functions} is a list of ways for Emms to
read the metadata in your media files, so that Emms can display the
song title, artist name, etc. @code{emms-info-native} is a metadata
reader written entirely in Emacs Lisp, but there are also other
backends which call external programs such as TinyTag, Taglib,
Exiftool, and etc.

Reload your Emacs initialization file, or restart Emacs to let the
changes have an effect.

Add all your music to a playlist by invoking @kbd{M-x
emms-add-directory-tree RET ~/my_music_directory/ RET}. When you do
this Emms will start reading metadata from the files and populating
the cache. This may take a while.

When you are done, you can load the browser with @kbd{M-x
emms-browser}, or view your playlist directly with @kbd{M-x
emms-playlist-mode-go} (when in the playlist you can hit @kbd{RET} on
a track to start playing it.)

Now you can start exploring Emms. It's probably best to begin with the
basic commands (@pxref{Basic Commands}), the interactive playlists
(@pxref{Interactive Playlists}), and the browser (@pxref{The Browser}).

More detail about setting up Emms can be found in the setup chapter,
@xref{Setup}.

Need help? There are knowledgeable people on the #emacs channel on irc
(irc.libera.chat), and Emms has a mailing list at emms-help@@gnu.org.


@c -------------------------------------------------------------------
@node Installation
@chapter Installation

@cindex installation

Emms is available via GNU ELPA, which takes care of all of the
following steps automatically.

If you are installing Emms manually, you need to put all the .el files
of emms in a directory in your load-path. For example, if you put all
those files into ~/elisp/emms/, then in your ~/.emacs, you should add:

@lisp
(add-to-list 'load-path "~/elisp/emms/lisp/")
@end lisp
@noindent

@menu
* Compiling Emms::      Compiling Emms into Byte-Code.
@end menu



@node Compiling Emms
@section Compiling Emms

@cindex compiling

If you are using XEmacs, you will need to edit @file{Makefile} as
follows before continuing.

@example
EMACS=xemacs
SITEFLAG=-no-site-file
@end example

You can byte-compile Emms by first entering the directory containing the
Emms source code, followed by invoking:

@command{make}

Which will byte compile Emms. You can then invoke:

@command{make install}

Which will install Emms into your Emacs directories (provided you have
the appropriate permissions to do so on your system).

Note that Emms is a light-weight and agile program, you can therefore
run Emms just fine without byte compiling it.


@c -------------------------------------------------------------------
@node Setup
@chapter Setup

@cindex setup
@cindex setting up Emms
@cindex quick setup

The `emms-setup' feature is provided by the file
@file{emms-setup.el}. It is essentially a collection of shortcuts for
loading different Emms features quickly, but everything you can do
with `emms-setup' can also be done manually.

We use `emms-setup' by calling one of the setup functions.

@defun emms-minimalistic
An Emms setup script.
Playlists and all the basics for playing media, but nothing else.
@end defun

@defun emms-all
An Emms setup script.
Loads all the stable features which come with the Emms distribution.
@end defun

`emms-setup' also comes with a convenience function to set a default
list of media players.

@defun emms-default-players
Set @var{emms-player-list} to @var{emms-setup-default-player-list}.
@end defun

You can of course write your own Emms setup functions like the above
by looking at the existing function definitions in
@file{emms-setup.el}.


@c -------------------------------------------------------------------
@node Configuration
@chapter Configuration

@cindex Configuration

This chapter discusses the configuration of Emms in more detail.

The following code fragment provides a minimal Emms setup without
using the layer of `emms-setup'. It can maybe be used to better
understand the internals of Emms. You can see how Emms needs to know
about players (these are defined in `emms-player-simple') and about
sources for tracks (trivial file system based sources, such as this
`emms-directory-tree', are defined in `emms-source-file').

@lisp
(require 'emms-player-simple)
(require 'emms-source-file)
(require 'emms-source-playlist)
(setq emms-player-list '(emms-player-mpg321
                         emms-player-ogg123
                         emms-player-mplayer))
@end lisp

For a discussion on how to define additional players, see @xref{Simple
Players}.

Much of the behaviour of Emms can be changed by setting
variables. For example:

@lisp
(setq emms-info-asynchronously nil)
(setq emms-playlist-buffer-name "*Music*")
@end lisp

The first @code{setq} turns off the asynchronous updating of info tags. The
second sets the default name of the Emms playlist buffer.

Another way to change Emms variables is to use the M-x
@command{customize} mechanism provided by Emacs.

@menu
* Finding files and speed::     Finding files quickly or portably.
* Setup Examples::              Examples of ways to setup Emms.
@end menu



@node Finding files and speed
@section Finding files and speed

@cindex files
@cindex speed

Emms needs to traverse directories in order to find playable
media. The default method Emms uses to achive this is
@code{emms-source-file-directory-tree-internal} as defined in
@file{emms-source-file.el}.  The above method is written portably and
will always work, but might be too slow if we want to load several
hundred tracks (or more).

@file{emms-source-file.el} defines another method for finding files,
@code{emms-source-file-directory-tree-find} which uses
GNU/find. @code{emms-source-file-directory-tree-find} is usually an
order of magnitude faster, but of course will not work if you do not
have GNU/find installed.

The method Emms will use is defined in the customisable variable
@var{emms-source-file-directory-tree-function}.


@node Setup Examples
@section Setup Examples

@cindex example
@cindex configuration

What follow are samples from real-world Emms configurations which show
some of the variety and breadth of modifications people make to the
default Emms setup.

The following excerpt includes dbus integration, defining a "recent"
filter for the @xref{The Browser}, persistent playlist via
@file{emms-history.el}, and enabling sending track information with
@file{emms-librefm-stream.el}:

@lisp
  ;; notifications
  (require 'emms-dbus)
  (emms-dbus-enable)
  ;; covers
  (setq emms-browser-covers #'emms-browser-cache-thumbnail-async)
  (setq emms-browser-thumbnail-small-size 64)
  (setq emms-browser-thumbnail-medium-size 128)
  ;; filters
  (emms-browser-make-filter "all" #'ignore)
  (emms-browser-make-filter "recent"
     (lambda (track) (< 30
        (time-to-number-of-days
  (time-subtract (current-time)
        (emms-info-track-file-mtime track))))))
  (emms-browser-set-filter (assoc "all" emms-browser-filters))
  ;; history
  (emms-history-load)
  ;; libre-fm
  (emms-librefm-scrobbler-enable)
@end lisp


In the following it is possible to see how some of defaults are set
regarding saving playlists, playlist interaction, adding special
arguments to a specific player backend and configuring player-specific
volume control options enabled via @file{emms-volume.el}.

@lisp
  (setq-default
   emms-source-file-default-directory "/mnt/db/mediaCore/sound_music/"

   emms-source-playlist-default-format 'm3u
   emms-playlist-mode-center-when-go t
   emms-playlist-default-major-mode 'emms-playlist-mode
   emms-show-format "NP: %s"

   emms-player-list '(emms-player-mpv)
   emms-player-mpv-environment '("PULSE_PROP_media.role=music")
   emms-player-mpv-parameters '("--quiet" "--really-quiet" "--no-audio-display" "--force-window=no" "--vo=null")

   emms-volume-change-function 'emms-volume-mpv-change
   emms-volume-mpv-method 'smart)
@end lisp


@c -------------------------------------------------------------------
@node Getting Help
@chapter Getting Help

@cindex mailing list
@cindex website

If you have a bug to report, need help, or wish to suggest a feature,
please feel free to use the Emms mailing list.  The address of the list
is emms-help@@gnu.org.  To subscribe to it, visit
@url{http://lists.gnu.org/mailman/listinfo/emms-help}.

If you are familiar with the Gmane service, there is a Gmane newsgroup
which mirrors this mailing address at gmane.emacs.emms.user.

Emms also has a website at @url{http://www.gnu.org/software/emms/}.


@c -------------------------------------------------------------------
@node Formats and Freedom
@chapter Formats and Freedom

@cindex freedom
@cindex format

Emms is free software, but some of the file formats it can play carry
restrictions, they are proprietary file formats. Proprietary software
companies are pushing out audio and video formats which restrict when,
where and how you can play them, and restrict developers from writing
free software which interacts with them.

Restrictive file formats put the corporate bottom-line before the
public interest.

Fortunately there are alternatives like Ogg. Ogg is a professional
grade multimedia format. Ogg Vorbis is the compressed audio format
(like MP3), and Ogg Theora is the video format. For more information,
go to @url{http://www.xiph.org/}.

If you want to transcode audio into a lossless format, you can try
FLAC (Free Lossless Audio Codec). FLAC stands out as the fastest and
most widely supported lossless audio codec, and the only one that at
once is non-proprietary, is unencumbered by patents and has the source
code for a reference implementation freely available. For more
information about FLAC, go to @url{http://flac.sourceforge.net/}.


@c -------------------------------------------------------------------
@node Basic Commands
@chapter Basic Commands

@cindex basic commands
@cindex commands, basic

Before you can use the interface commands, you need a playlist to
start with. The following commands allow you to add to the current
playlist from different sources:

Note that the commands with the ``emms-add-'' prefix add the source to
the playlist but do not start playing it immediately. Conversely, the
commands with the ``emms-play-'' prefix begin playing the track
immediately.

This creates the active playlist and queue as needed. The active queue will automatically switch to any playlists that are browsed to such that the next song played will come from the currently viewed playlist.

Locking the active playlist queue to its playlist will prevent it from changing, allowing for browsing other playlists and sending songs to the current active playlist from them.

Locking the queue to its playlist allows for live creation of a curated playlist by browsing other playlists as well as the music database and files.

@defun emms-play-file file
A source for a single file - either @var{file}, or queried from the
user. If called with a prefix the file will be added like
@command{emms-add-file}.
@end defun
@defun emms-add-file file
A source for a single file - either @var{file}, or queried from
the user. If called with a prefix the file will be played like
@command{emms-play-file}.
@end defun
@defun emms-play-directory dir
A source for a whole directory tree - either @var{dir}, or queried
from the user.
@end defun
@defun emms-add-directory dir
A source for a whole directory tree - either @var{dir}, or queried
from the user.
@end defun
@defun emms-play-directory-tree dir
A source for multiple directory trees - either @var{dir}, or the
value of @var{emms-source-file-default-directory}.
@end defun
@defun emms-add-directory-tree dir
A source for multiple directory trees - either @var{dir}, or the
value of @var{emms-source-file-default-directory}.
@end defun
@defun emms-play-url url
A source for an @var{url} - for example, for streaming over http,
playing over sftp, or playing local files (with the ``file://''
scheme).
@end defun
@defun emms-add-url url
A source for an @var{url} - for example, for streaming over http,
playing over sftp, or playing local files (with the ``file://''
scheme).
@end defun
@defun emms-play-playlist playlist
A source for the M3u or PLS playlist format from the file @var{playlist}.
@end defun
@defun emms-add-playlist playlist
A source for the M3u or PLS playlist format from the file @var{playlist}.
@end defun
@defun emms-play-find dir regexp
A source that will find files in @var{dir} or
@var{emms-source-file-default-directory} which match @var{regexp}.
@end defun
@defun emms-add-find dir regexp
A source that will find files in @var{dir} or
@var{emms-source-file-default-directory} which match @var{regexp}.
@end defun

The basic functionality of Emms is just to play music without being
noticed. It provides a few commands to skip the current track and
such, but other than that it doesn't show up. Emms provides the
following basic user commands (which you might want to bind to
keystrokes):

@defun emms-start
Start playing the current playlist
@end defun
@defun emms-stop
Stop playing
@end defun
@defun emms-next
Start playing the next track in the playlist
@end defun
@defun emms-previous
Start playing previous track in the playlist
@end defun
@defun emms-shuffle
Shuffle the current playlist. This uses
@var{emms-playlist-shuffle-function}.
@end defun
@defun emms-sort
Sort the current playlist. This uses
@var{emms-playlist-sort-function}.
@end defun
@defun emms-lock-queue
Lock the current active playlist queue to its playlist.
@var{emms-playlist-sort-function}.
@end defun
@defun emms-unlock-queue
Unlock the current active playlist queue from its playlist.
@var{emms-playlist-sort-function}.
@end defun
@defun emms-show &optional insertp
Describe the current Emms track in the minibuffer. If @var{insertp} is
non-nil, insert the description into the current buffer instead. This
function uses @var{emms-show-format} to format the current track.
@end defun
The command @command{emms-show-all} will pop up a window with the
complete information about the track being
played. @command{emms-show-all} is provided by
@file{emms-show-all.el}, which is included in the `emms-all' setup
level. See @xref{Setup}.


@c -------------------------------------------------------------------
@node The Core File
@chapter The Core File

@cindex core file
@cindex heart of Emms
@cindex primitive functions

The core file @file{emms.el} provides the all basic functions for
playing music, generating playlists and defining players.

@menu
* User Variables::     Variables for the user to tweak.
* Hooks::              Hooks for important Emms functions.
* Core Functions::     Providing the basic functionality of Emms.
@end menu



@node User Variables
@section User Variables

@cindex user variables
@cindex options

The core file defines a number of user variables.

@defopt emms-player-list
A list of players Emms can use. You need to set this in order to use
Emms to play media.
@end defopt
@defopt emms-show-format
The format to use for @command{emms-show}. Any "%s" is replaced by
what @var{emms-track-description-function} returns for the currently
playing track.
@end defopt
@defopt emms-repeat-playlist
Non-nil if the Emms playlist should automatically repeat the playlist.
If nil, playback will stop when the last track finishes playing.
@end defopt
@defopt emms-track-description-function
Function for describing an Emms track in a user-friendly way.
@end defopt
@defopt emms-sort-lessp-function
A function that compares two tracks, and returns non-nil if the first
track should be sorted before the second (see also @code{sort}).
@end defopt



@node Hooks
@section Hooks

@cindex hooks
@cindex adding functionality

The core file provides hook variables for the basic functionality of
Emms.

@defopt emms-player-started-hook
A hook run when an Emms player started playing.
@end defopt
@defopt emms-player-stopped-hook
A hook run when an Emms player stopped playing. See also
@var{emms-player-finished-hook}.
@end defopt
@defopt emms-playlist-source-inserted-hook
Hook run when a source got inserted into the playlist. The buffer is
narrowed to the new tracks.
@end defopt
@defopt emms-playlist-selection-changed-hook
Hook run after another track is selected in the Emms playlist.
@end defopt
@defopt emms-playlist-cleared-hook
Hook run after the current Emms playlist is cleared. This happens both
when the playlist is cleared and when a new buffer is created for it.
@end defopt
@defopt emms-player-finished-hook
Hook run when an Emms player finishes playing a track. Please pay
attention to the differences between @var{emms-player-finished-hook}
and @var{emms-player-stopped-hook}. The former is called only when the
player is stopped interactively; the latter, only when the player
actually finishes playing a track.
@end defopt
@defopt emms-player-paused-hook
Hook run when a player is paused or resumed. Use
@var{emms-player-paused-p} to find the current state.
@end defopt



@node Core Functions
@section Core Functions

@cindex core functions
@cindex basic functions

The core file also defines all the functions important to the basic
use of Emms.

There are functions which deal with movement in the playlist.

@defun emms-next-noerror
Start playing the next track in the Emms playlist. Unlike
@code{emms-next}, this function doesn't signal an error when called at
the end of the playlist. This function should only be called when no
player is playing. This is a good function to put in
@code{emms-player-finished-hook}.
@end defun
@defun emms-playlist-next
Move to the next track in the current buffer.
@end defun
@defun emms-playlist-previous
Move to the previous track in the current buffer.
@end defun
@defun emms-random
Jump to a random track.
@end defun
@defun emms-toggle-repeat-playlist
Toggle whether emms repeats the playlist after it is done. See
@var{emms-repeat-playlist}.
@end defun
@defun emms-toggle-repeat-track
Toggle whether emms repeats the current track. See
@var{emms-repeat-track}.
@end defun
@defun emms-toggle-random-playlist
Toggle whether emms plays the tracks randomly or sequentially. See
@end defun
@var{emms-random-playlist}.

Some functions deal with the getting and setting track information.

@defun emms-track type name
Create a track with type @var{type} and name @var{name}.
@end defun
@defun emms-track-type track
Return the type of @var{track}.
@end defun
@defun emms-track-name track
Return the name of @var{track}.
@end defun
@defun emms-track-get name track &optional inexistent
Return the value of @var{name} for @var{track}. If there is no value,
return @var{default} (or nil, if not given).
@end defun
@defun emms-track-set track name value
Set the value of @var{name} for @var{track} to @var{value}.
@end defun
@defun emms-track-description track
Return a description of @var{track}. This function uses
@var{emms-track-description-function}.
@end defun
@defun emms-player-for track
Return an Emms player capable of playing @var{track}. This will be the
first player whose PLAYABLEP function returns non-nil, or nil if no
such player exists.
@end defun
@defun emms-playlist-current-selected-track
Return the currently selected track in the current playlist.
@end defun

There are also functions which deal with the playing itself.

@defun emms-player-start track
Start playing @var{track}.
@end defun
@defun emms-player-stop
Stop the currently playing player.
@end defun
@defun emms-player-stopped
Declare that the current Emms player is finished.
This should only be done by the current player itself.
@end defun

@defun emms-seek duration
Seek the current player by @var{duration} from its current position.
The argument @var{duration} can be:

@itemize @minus

@item
A single number, in which case it is interpreted as seconds.

@item
A string of form @verb{|[-][HH:]MM:SS.m|}, where @verb{|HH|} is hours,
@verb{|MM|} is minutes, and @verb{|SS|} is seconds.

@end itemize

In both forms seconds can be a floating point number.  A negative
value seeks backwards.
@end defun

@defun emms-seek-to timestamp
Seek the current player to @var{timestamp}.  Acceptable forms for
@var{timestamp} are the same as time duration in @code{emms-seek},
except that timestamps cannot be negative.
@end defun

@defun emms-seek-forward
Seek ten seconds forward.
@end defun
@defun emms-seek-backward
Seek ten seconds backward.
@end defun

For more basic commands defined in the core file see @xref{Basic
Commands}.


@c -------------------------------------------------------------------
@node Sources
@chapter Sources

@cindex Sources

Sources allow Emms to add and play tracks. Emms comes with a number of
sources of its own. Sources are designed so that creating new ones
will be easy.

For examples of Emms sources for files and directories see
@file{emms-source-file.el}.

@defopt emms-source-file-default-directory
The default directory to look for media files.
@end defopt
@defun emms-play-find
Play all files in @var{emms-source-file-default-directory} that match
a specific regular expression.
@end defun
@defun emms-source-file &optional file
An Emms source for a single file - either @var{file}, or queried from the
user.
@end defun
@defun emms-source-files files
An Emms source for a list of @var{files}.
@end defun
@defun emms-source-directory &optional dir
An Emms source for a whole directory tree - either @var{dir}, or queried
from the user
@end defun
@defun emms-source-directory-tree & optional dir
An Emms source for multiple directory trees - either @var{dir}, or the
value of @var{emms-source-file-default-directory}.
@end defun
@defun emms-source-playlist file
An Emms source for playlists.  See @var{emms-source-playlist-formats}
for a list of supported formats.
@end defun
@defun emms-source-playlist-native file
An Emms source for a native Emms playlist file.
@end defun
@defun emms-source-playlist-m3u file
An Emms source for an m3u playlist file.
@end defun
@defun emms-source-playlist-pls file
An Emms source for a pls playlist file.
@end defun
@defun emms-source-find &optional dir regex
An Emms source that will find files in @var{dir} or
@var{emms-source-file-default-directory} that match @var{regexp}.
@end defun
@defun emms-source-beets database filter sort
An Emms source that will read a @command{beets} library database
(requires Emacs to be built with SQLite support).  With prefix
argument @var{filter}, interactively filter the database.  With a
double (or more) prefix argument, also set @var{sort} interactively;
otherwise use @var{emms-source-beets-sort-columns}.  If @var{database}
is omitted or nil, @var{emms-source-beets-database} is used.
@end defun
@defun emms-source-file-directory-tree &optional dir
Return a list of all files under @var{dir} which match @var{regex}.
@end defun
@defun emms-play-dired
Play all marked files of a dired buffer
@end defun
@defun emms-add-dired
Add all marked files of a dired buffer
@end defun
@defun emms-source-file-regex
Return a regexp that matches everything any player (that supports
files) can play.
@end defun
@defun emms-locate regexp
Search for @var{regexp} and display the results in a locate buffer
@end defun


@c -------------------------------------------------------------------
@node Simple Players
@chapter Simple Players

@cindex players, simple

@defmac define-emms-simple-player name types regex command &rest args
Define a simple player.
@var{name} is used to construct the name of the function like
emms-player-@var{name}. @var{types} is a list of track types
understood by this player. @var{regex} must be a regexp that matches
the filenames the player can play. @var{command} specifies the command
line argument to call the player and @var{args} are the command line
arguments.
@end defmac

For a discussion on how to define new players see @xref{New Player}.

@defun emms-player-simple-stop
Stop the currently playing process, if indeed there is one.
@end defun
@defun emms-player-simple-start filename cmdname params
Starts a process playing @var{filename} using the specified @var{cmdname} with
the specified @var{params}.
@end defun
@defun emms-player-simple-sentinel proc str
Sentinel for determining the end of process for the process @var{proc}
and the sentinel string @var{str}.
@end defun


@c -------------------------------------------------------------------
@node Playlists
@chapter Playlists

@cindex organizing tracks and media

Emms uses Emacs buffers to store the media tracks for playing. We call
one such buffer a ``playlist buffer'' or an ``Emms playlist
buffer''. Emms then proceeds to play the media tracks in the buffer
from top to bottom until the end of the playlist.

The name of the playlist buffer is defined in the variable
@var{emms-playlist-buffer-name} and is set to be an invisible Emacs
buffer by default. You can change to any name you want. For an example
configuration see @xref{Configuration}.

You can create any number of playlist buffers you wish. At any time
Emms has a single ``current'' buffer through which it proceeds track
by track. A saved playlist can be added to the current buffer by
calling @kbd{M-x emms-add-playlist} or @kbd{M-x emms-play-playlist},
which also plays the tracks immediately.

The current Emms playlist buffer is stored in the variable
@var{emms-playlist-buffer}.

@defun emms-playlist-new &optional name
Create a new playlist buffer.
The buffer is named @var{name}, but made unique. @var{name} defaults
to `emms-playlist-buffer-name'. If called interactively, the new
buffer is also selected.
@end defun

@defun emms-playlist-save &optional format file
Store the current playlist to FILE as the type FORMAT.  The default
format is specified by @var{emms-source-playlist-default-format}.
@end defun

@defun emms-playlist-clear
Clears the playlist buffer.
@end defun

@defun emms-playlist-current-clear
Clear the current playlist. If no current playlist exists, a new one
is generated.
@end defun

@defun emms-playlist-current-kill
Kill the current EMMS playlist buffer and switch to the next one.
@end defun

@defun emms-playlist-length
Display the total playing time of the current playlist.
@end defun

@defun emms-playlist-total-playing-time
Alias for @code{emms-playlist-length}.
@end defun


@c -------------------------------------------------------------------
@node Track Information
@chapter Track Information

@cindex track information
@cindex info tags

By default Emms will only list tracks as file names or URLs in
playlists (@pxref{Playlists}) and the browser (@pxref{The Browser}).
However, Emms can be configured to utilize so-called @dfn{info
methods} to augment tracks with metadata information, such as artist
name, track name, album title, and the like.  We describe these
methods and their use in this chapter.

Fundamentally, info methods are Emacs Lisp functions that are called
for each track to provide information for that track.  Current info
methods in Emms are restricted to tracks that are files; they do not
work with stream URLs (@pxref{Streaming Audio}).  Some of the methods
require installation of some additional software that Emms can then
call to read metadata from disk (@pxref{Metadata Utilities}).
Finally, some methods work only with a limited set of media file
formats such as Ogg or MP3, while some methods support a wide variety
of formats.

If caching is enabled (it is by default) then the metadata for each
track will be stored in the cache for faster retrieval. That means if
you change info method and want updated tracks, you will have to reset
the cache @kbd{M-x emms-cache-reset} and then repopulate with @kbd{M-x
emms-add-directory-tree RET ~/Music/ RET} or similar.

Automatic track information retrieval is enabled by default in the
@code{emms-all} setup level (@pxref{Setup}).  That setup level
configures Emms to use @code{emms-info-native} and
@code{emms-info-cueinfo} methods, as they are the only methods that do
not rely on additional software.

Here is a list of all info methods distributed with Emms and their
software requirements:

@table @code

@item emms-info-native
This method is implemented completely in Emacs Lisp and hence does not
require any external software.  It supports Ogg Vorbis, Opus, FLAC and
MP3 files.

@item emms-info-tinytag
This method utilizes a small Python library @code{tinytag}.  It
supports MP3, Ogg Vorbis, Opus, MP4, M4A, FLAC, WMA and WAV formats.

@item emms-info-exiftool
This method calls @command{exiftool} utility written in Perl.  It
supports dozens of media file formats, far too many to list here.

@item emms-info-libtag
This method calls a small ``shim'' executable
@command{emms-print-metadata} built around TagLib library.  It
supports MP3, Ogg Vorbis, Opus, FLAC, MPC, Speex, WavPack, TrueAudio,
WAV, AIFF, MP4 and ASF formats.

@item emms-info-metaflac
This method calls @command{metaflac} utility.  It works only with FLAC
files.

@item emms-info-mp3info
This method calls @command{mp3info} utility.  It works only with MP3
files that have older id3v1 tags.

@item emms-info-ogginfo
This method calls @command{ogginfo} utility.  It supports Ogg Vorbis
and Theora formats.

@item emms-info-opusinfo
This method calls @command{opusinfo} utility.  It works only with Opus
files.

@item emms-info-cueinfo
This is a special method that parses track information from an
accompanying cue file for FLAC and APE files (@pxref{APE / FLAC
Commands}).  It does not require any additional software.

@end table

To use any of the methods, add the method to
@code{emms-info-functions} list.  For example:

@lisp
(require 'emms-info-native)
(add-to-list 'emms-info-functions 'emms-info-native)
@end lisp

@noindent
You can also use a combination of format-specific tools if needed:

@lisp
(require 'emms-info-mp3info)
(require 'emms-info-ogginfo)
(add-to-list 'emms-info-functions 'emms-info-mp3info 'emms-info-ogginfo)
@end lisp

@noindent
In this case both @code{emms-info-mp3info} and
@code{emms-info-ogginfo} will be called for each track.

There are a number of user variables which control the behavior of
@code{emms-info}:

@defopt emms-info-auto-update
Non-nil when Emms should update track information if the file changes.
This will cause hard drive activity on track loading. If this is too
annoying for you, set this variable to nil.
@end defopt

@defopt emms-info-asynchronously
Non-nil when track information should be loaded asynchronously. This
requires the feature @code{later-do} which is provided by the file
@file{later-do.el}, which comes with Emms.  See variable
@code{emms-later-do-batch} for performance tweaking.
@end defopt

@defopt emms-info-functions
A list of functions (info methods) which add information to tracks.
Each function is called with a track as argument.  If two info methods
produce the same information (for example album name), the latter one
takes precedence.
@end defopt

@menu
* Metadata Utilities::       Supported external metadata utilities.
* Defining Info Methods::    How to define new info methods.
@end menu



@node Metadata Utilities
@section Metadata Utilities

With the exception of @code{emms-info-native} and
@code{emms-info-cueinfo}, Emms info methods require external metadata
utilities to read metadata from media files.  If you plan to use a
certain info method, make sure you have the corresponding utility
installed.  All of these utilities are free software, and most of them
are included in free GNU/Linux distributions.

@subsubheading tinytag

tinytag is a Python library for reading metadata from music files.  It
is available at @url{https://pypi.org/project/tinytag/}.  Naturally a
working Python interpreter is also required.  The corresponding Emms
info method is @code{emms-info-tinytag}.

It is best to configure @code{emms-info-tinytag} as the sole info
method for Emms, because competing and overlapping methods can cause
confusion.  To use it, add the following into your Emacs initialization file:

@lisp
(require 'emms-info-tinytag)
(setq emms-info-functions '(emms-info-tinytag))
@end lisp

@subsubheading ExifTool

ExifTool is a platform-independent Perl library and a command-line
application for reading, writing and editing meta information in a
wide variety of files.  It is available at
@uref{https://exiftool.org/}.  Naturally a working Perl interpreter is
also required.  The corresponding Emms info method is
@code{emms-info-exiftool}.

It is best to configure @code{emms-info-exiftool} as the sole info
method for Emms, because competing and overlapping methods can cause
confusion.  To use it, add the following into your Emacs
initialization file:

@lisp
(require 'emms-info-exiftool)
(setq emms-info-functions '(emms-info-exiftool))
@end lisp

@subsubheading TagLib

TagLib is a library for reading and editing metadata of several
popular audio formats.  It is available at
@url{http://taglib.github.io/}.  Because TagLib is a C++ library
instead of an executable program, you have to build and install a
small ``shim'' executable @command{emms-print-metadata} around it.
@code{emms-info-libtag} will then call this executable to read
metadata from media files.

To compile @command{emms-print-metadata} invoke

@command{make emms-print-metadata}

@noindent
in Emms directory.  For this to succeed you need to have a working C++
compiler and TagLib development libraries installed on your system.
The resultant binary executable will be installed when you invoke

@command{make install} as in @xref{Compiling Emms}.

@noindent
It is of course also possible to install only the
@file{emms-print-metadata} binary where your system can find and
execute it without installing all of Emms via the make command.

Once @command{emms-print-metadata} is available, it is best to
configure @code{emms-info-libtag} as the sole info method for Emms,
because competing and overlapping methods can cause confusion.  To use
it, add the following into your Emacs initialization file:

@lisp
(require 'emms-info-libtag)
(setq emms-info-functions '(emms-info-libtag))
@end lisp

@subsubheading metaflac

@command{metaflac} is the command-line FLAC file metadata editor.  It
is included in FLAC source distribution available at
@url{https://github.com/xiph/flac}.  The corresponding info method is
@code{emms-info-metaflac}.  To use it, add the following into your
Emacs initialization file:

@lisp
(require 'emms-info-metaflac)
(add-to-list 'emms-info-functions 'emms-info-metaflac)
@end lisp

@subsubheading MP3info

MP3info is a small utility for reading and modifying id3v1 tags from
MP3 files.  Note that more recent id3v2 tags are not supported; for
those you need to use another info method, for example
@code{emms-info-native}.  MP3info is available at
@url{https://ibiblio.org/mp3info/}.

The corresponding info method is @code{emms-info-mp3info}.  To use it,
add the following into your Emacs initialization file:

@lisp
(require 'emms-info-mp3info)
(add-to-list 'emms-info-functions 'emms-info-mp3info)
@end lisp

@subsubheading ogginfo

@command{ogginfo} is a small utility for extracting information about
Ogg Vorbis and Theora files.  It is part of Vorbis Tools source
distribution available at @url{https://github.com/xiph/vorbis-tools}.
The corresponding info method is @code{emms-info-ogginfo}.  To use it,
add the following into your Emacs initialization file:

@lisp
(require 'emms-info-ogginfo)
(add-to-list 'emms-info-functions 'emms-info-ogginfo)
@end lisp

@subsubheading opusinfo

@command{opusinfo} is a small utility for extracting information about
Opus files.  It is part of Opus Tools source distribution available at
@url{https://github.com/xiph/opus-tools}.  The corresponding info
method is @code{emms-info-opusinfo}.  To use it, add the following
into your Emacs initialization file:

@lisp
(require 'emms-info-opusinfo)
(add-to-list 'emms-info-functions 'emms-info-opusinfo)
@end lisp

@node Defining Info Methods
@section Defining Info Methods

@cindex defining info methods

An info method essentially consists of a function which, given an Emms
track, sets the appropriate @dfn{info-symbols} for that track.  Info
symbols are keys that have an associated value stored in the
@dfn{metadata cache}.  While info symbols can have arbitrary names,
the following symbols are recognized by Emms:

@table @code
@item info-album
Album title.

@item info-albumsort
Album title for collation.

@item info-artist
Artist name.

@item info-artistsort
Artist name for collation.

@item info-albumartist
Album artist name.

@item info-albumartistsort
Album artist name for collation.

@item info-composer
Composer name.

@item info-composersort
Composer name for collation.

@item info-date
Release date.

@item info-originaldate
Original release date.

@item info-performer
Performer name.

@item info-title
Track title.

@item info-titlesort
Track title for collation.

@item info-tracknumber
Track number.

@item info-discnumber
Disc number.

@item info-year
Release year.

@item info-originalyear
Original release year.

@item info-note
Free-form note.

@item info-genre
Genre.

@item info-label
Record label.

@item info-playing-time
Playing time in seconds.

@end table

@noindent
An info method does not need to add all of these symbols into the
given track.  It can also add other symbols, but those extra symbols
won't be used by Emms.

We can for example look at the predefined method for retrieving
information about audio tracks in the Ogg format.  The function
@code{emms-info-ogginfo} provided by @file{emms-info-ogginfo.el}
accepts an Emms track @var{track} as a single argument.  It uses
@command{ogginfo} utility to extract a list of key-value metadata
pairs from the file represented by @var{track}.  Next, it sets the
appropriate info symbols for @var{track} by calling
@code{emms-track-set}.  Info symbols are interned from the extracted
keys.  Those keys can be arbitrary strings, but they typically
coincide with the keys listed above; for example ``album'' and
``artist'' form info symbols @code{info-album} and @code{info-artist}.

@c -------------------------------------------------------------------
@node Interactive Playlists
@chapter Interactive Playlists

@cindex Interactive Playlists

Emms provides a visual, interactive playlist mode as well as the
ability to use playlists without ever looking at then. This visual,
interactive mode is called the `emms-playlist-mode' and is defined in
@file{emms-playlist-mode.el}.

The interactive playlist mode is enabled by default in the `emms-all'
setup level. For more information about Emms setup levels see
@xref{Setup}.

@defun emms-playlist-mode-go
Switch to the current emms-playlist buffer and use emms-playlist-mode.
@end defun

If you wish to make this the default Emms playlist mode, add the
following to your @file{.emacs}.

@lisp
(setq emms-playlist-default-major-mode 'emms-playlist-mode)
@end lisp

The interactive playlist buffer shows the tracks in the current Emms
playlist in the order in which they will be played. The current track
will be highlighted.

When in the interactive playlist mode we can perform different actions
on the current playlist.

@table @kbd

@item a
@findex emms-playlist-mode-add-contents
Add files in the playlist at point to the current playlist buffer.
If we are in the current playlist, make a new playlist buffer and
set it as current.

@item i
@findex emms-playlist-playlist-insert-track
Insert track at point into active playlist.

@item b
@findex emms-playlist-set-playlist-buffer
Set the current playlist buffer.

@item n
@findex emms-next
Start playing the next track in the playlist.

@item p
@findex emms-next
Start playing the previous track in the playlist.

@item s
@findex emms-stop
Stop playing.

@item P
@findex emms-pause
Pause.

@item >
@findex emms-seek-forward
Seek ten seconds forward.

@item <
@findex emms-seek-backward
Seek ten seconds backward.

@item f
@findex emms-show
Describe the currently playing track in the minibuffer.

@item c
@findex emms-playlist-mode-center-current
Display the current track in the center of the screen.

@item RET
@findex emms-playlist-mode-play-current-track
Start playing the track under point. Note that this is also available
with @kbd{<mouse-2>}.

@item SPC
@findex scroll-up
Scroll up a near full page.

@item M-<
@findex emms-playlist-mode-first
Go to the first track in the playlist.

@item M->
@findex emms-playlist-mode-last
Go to the last track in the playlist.

@item r
@findex emms-random
Go to a randomly selected track in the playlist.

@item q
@findex bury-buffer
Put the interactive playlist buffer at the end of the list of all
buffers.

@item C-x C-s
@findex emms-playlist-save
Save the current playlist buffer to a file. By default, Emms will ask
you for confirmation before overwriting an existing playlist. You can
silently overwrite existing playlist by setting
@var{emms-source-playlist-ask-before-overwrite} to nil.

@item ?
@findex describe-mode
Describe the mode.

@item C-i
@findex emms-playlist-mode-shift-track-up
Shift the track at point up one line.

@item C-o
@findex emms-playlist-mode-shift-track-down
Shift the track at point down one line.

@item M-n
@findex emms-playlist-mode-next
Switch to the next playlist buffer.

@item M-p
@findex emms-playlist-mode-previous
Switch to the previous playlist buffer.


@end table

We can also edit the playlist using familiar GNU/Emacs commands:

@table @kbd

@item C-k
@findex emms-playlist-mode-kill-track
Remove the track under point from the playlist buffer. Also available
using the @kbd{d} key.

@item C-y
@findex emms-playlist-mode-yank
See the command @command{yank}

@item M-y
@findex emms-playlist-mode-yank-pop
See the command @command{yank-pop}.

@item C-j
@findex emms-playlist-mode-insert-newline
Insert a newline at point.
@end table

We can use the regular GNU/Emacs killing and yanking commands to move
and copy tracks in between playlist buffers. We can use the same
commands to insert arbitrary text into the playlist buffers together
with the playlist tracks. Text which is not a track is ignored by the
program and can therefore be used to include titles and annotations
within the playlist.


@c -------------------------------------------------------------------
@node Markable Playlists
@chapter Markable Playlists

@cindex Markable Playlists

The Markable Playlists provided by the file @file{emms-mark.el} are an
alternative to the default interactive playlists, @xref{Interactive
Playlists}. They allow marking tracks with keybindings familiar to users
of dired.

To enable the Markable Playlists you have to add

@lisp
(require 'emms-mark)
@end lisp

to your @file{.emacs}. Then you can activate @command{emms-mark-mode} by
executing @command{M-x emms-mark-mode} in a playlist buffer. You can
return to the default interactive playlist mode with @command{M-x
emms-mark-mode-disable}.

If you wish to make this the default Emms playlist mode, add the
following to your @file{.emacs}.

@lisp
(setq emms-playlist-default-major-mode 'emms-mark-mode)
@end lisp

@table @kbd

@item m
@findex emms-mark-forward
Marks the current track and sets point one line forward. If a prefix
argument ARG is given, it will mark the next ARG tracks and set point
accordingly. A negative argument marks backward.

@item U
@findex emms-mark-unmark-all
Unmarks all tracks in the playlist.

@item t
@findex emms-mark-toggle
Toggles mark on the current track.

@item u
@findex emms-mark-unmark-forward
Unmarks same way as @command{emms-mark-forward} marks.

@item % m
@findex emms-mark-regexp
Marks all tracks in the playlist matching the given regular
expression. A prefix argument means to unmark them instead.
@end table

When tracks are marked you can operate on them:

@table @kbd

@item D
@findex emms-mark-delete-marked-tracks
Deletes the marked tracks from the playlist.

@item K
@findex  emms-mark-kill-marked-tracks
Deletes the marked tracks from the playlist and places them in the
kill-ring, so that you can @command{yank} in into another playlist.

@item W
@findex emms-mark-copy-marked-tracks
Adds the marked tracks to the kill-ring, so that you can @command{yank}
them into another playlist.
@end table

emms-mark is also intent to provide a way for user to select tracks
for other command to operate on them. Currently,
@file{emms-tag-editor.el} uses the emms-mark to edit the tags of
selected tracks. Two functions are useful for the elisp programer to
handle marked tracks.

@defun emms-mark-do-with-marked-track
This function take a function to perform on all marked tracks. A
optional argument `move-flag' to tell the function to move forward
line after calling given function. If the given function didn't change
position, the second argument should set to non-nil.
@end defun

@defun emms-mark-mapcar-marked-track
This function is very similar to `emms-mark-do-with-marked-track'
except it collects result of given function (that's why named with
`mapcar').
@end defun



@c -------------------------------------------------------------------
@node Extending Emms
@chapter Extending Emms

@cindex new players
@cindex defining players
@cindex new players, defining

Emms introduces a high abstraction layer for playing music so you can
customise it to your needs.

@menu
* New Player::               How to define a new player.
* Simple Player for `play':: An example player using @command{play}.
* More Complex Player::      Example of a complex player using @command{mpg321}.
@end menu



@node New Player
@section New Player

@cindex new player
@cindex defining new players

The file @file{emms-player-simple.el} defines some easy players to
start with, but it shouldn't be hard to provide a function for your
favourite player. We will start with an easy example that shows how
we can use the @command{play} command under Unix to play our WAV files.



@node Simple Player for `play'
@section Simple Player for `play'

@cindex simple player
@cindex primitive player
@cindex basic player

Play is a very easy command line player for various format. If you
want your emms to play WAV files just put the following lines in you
@file{.emacs}:

@lisp
(require 'emms-player-simple)
(define-emms-simple-player play '(file) "\\.wav$" "play")
@end lisp
@noindent

Huh! Wasn't that easy?

The macro function @command{define-emms-simple-player} takes a minimum
of three arguments. The first argument (@emph{play} in our example)
defines the name of the player. It's used to name the player
functions. The second is a regexp, that defines which files to play
with our player. @emph{\\.wav$} matches any filename ending with a dot
and the string wav. The last argument is the actual command line
command we use to play our files. You can also add the path but we
just assume that the command is in your path. All arguments you add to
these three are optional. They define the command line arguments you
want to add to your argument. If you want to hear the wav file of your
favourite artist in the most possible volume use the following line:

@lisp
(require 'emms-player-simple)

(define-emms-simple-player play
                           '(file)
                           "\\artist-*.wav$"
                           "play"
                           "--volume=100")
@end lisp
@noindent

Please notice that you have to add the arguments as strings!

The command line tool you use for @command{define-emms-simple-player}
has to take one song as argument and stop after playing that
particular song. For any other concept you will need to customise
emms a bit more...



@node More Complex Player
@section More Complex Player

@cindex complex player
@cindex advanced player

The most players you use will be simple players so you don't need to
read this chapter. But if you are curious how you can use (almost) every
player in emms read further...

In this chapter we will use mpg321 to construct a player that
actually can pause a track, restart it and show rest time. We won't
implement all of that, but after that chapter you will know how to
define it.

The command @command{define-emms-simple-player} is just a abstraction
layer for @command{define-emms-player}, which is a little bit more
complicated but much more powerful!

@lisp
(define-emms-player "emms-mpg321-remote"
  :start 'emms-mpg321-remote-start
  :stop 'emms-mpg321-remote-stop
  :playablep 'emms-mpg321-remote-playable-p)
@end lisp
@noindent

So, that is almost all! @command{define-emms-player} takes a minimum
of three arguments. The first is the name of the player. The rest are
methods with functions to call. Three methods are required: start,
stop and playable. Start says Emms how to start a track (sic!), stop
how to stop a player and playablep should return non-nil if the player
can play the track.

So we just need these three functions to get our mpg321-remote:

First we code the start function. We will check if there's a open
process and start one otherwise. Then we send a string to the process
with the filename and set a filter.

@lisp
(defun emms-mpg321-remote-start ()
  (unless (get-process ``mpg321-remote'')
    (setq emms-mpg321-remote-process
          (start-process "mpg321-remote-process"
                         "*mpg321*" "mpg321" "-R" "abc"))
  (process-send-string "mpg321-remote-process"
                       (concat "l " (emms-track-name track)))
  (set-process-filter emms-mpg321-remote-process 'emms-mpg321-remote-filter)))
@end lisp
@noindent

We need the filter, as mpg321-remote won't quit after playing the
track as the simple player do. We wait until the process sends the
output ``(at-sign)P 0'' (the signal of mpg321 that the song ended) to the
filter and call emms-mpg321-remote-stop.

@lisp
(defun emms-mpg321-remote-filter (process output)
  (when (string-match "(at-sign)P 0" output)
    (emms-mpg321-remote-stop)))
@end lisp
@noindent

@command{emms-mpg321-remote-stop} won't do anything interesting. It
just test if there are other files to play and close the process otherwise.

@lisp
(defun emms-mpg321-remote-stop ()
  (unless emms-playlist
    (process-send-string "mpg321-remote-process" "Q\n"))
@end lisp
@noindent

And to make that a playable example I also added
@command{emms-mpg321-remote-playablep}, which I really just steal
from @file{emms-player-simple.el}

@lisp
(defun emms-mpg321-remote-playablep (track)
       "Return non-nil when we can play this track."
       (and (emms-track-file-p track)
@end lisp
@noindent

Now we have a ready player and we could add commands like
@command{emms-mpg321-remote-pause} for example.



@c -------------------------------------------------------------------
@node The Browser
@chapter The Browser

The Browser allows you to browse the metadata cache and add tracks to
your playlist. It includes a powerful interactive mode.

The Browser is defined in @file{emms-browser.el} and is included in
the @command{emms-all} setup level. For more information about Emms
setup levels see @xref{Setup}.

You can also manually add the Browser to your Emms setup by loading it
explicitly with:

@lisp
(require 'emms-browser)
@end lisp

To be properly useful, you should do M-x
@command{emms-add-directory-tree} to all the files you own at least
once so that the cache is fully populated.

@menu
* Browser Interface::     The interactive browser interface.
* Displaying Covers::     Displaying album covers in the browser interface.
* Changing Looks::        Changing the tree structure, display format and faces.
* Filtering Tracks - deprecated::  Displaying a subset of the tracks.
@end menu



@node Browser Interface
@section Browser Interface

The browser interface allows you to display and interact with your
tracks in many different ways. There are a number of ways to start the
browser.

@defun emms-smart-browse
Display browser and playlist. Toggle between selecting browser,
playlist or hiding both. Tries to behave sanely if the user has
manually changed the window configuration.
@end defun

@defun emms-browse-by-artist
Display the browser and order the tracks by artist.
@end defun

@defun emms-browse-by-album
Display the browser and order the tracks by album.
@end defun

@defun emms-browse-by-genre
Display the browser and order the tracks by genre.
@end defun

@defun emms-browse-by-year
Display the browser and order the tracks by year.
@end defun

@defun emms-browser-show-searches
Show Search crumbs of the active searches.
@end defun

@defun emms-browser-render-last-search
Render the results for the last search with current settings.
@end defun

Once the Browser is displayed you can use it to managed your track
collection and playlists. The Browser is interactive and has its own
keybindings.

@table @kbd

@item C-j
@kindex C-j (emms-browser)
@findex emms-browser-add-tracks-and-play
Add all tracks at point, and play the first added track.

@item RET
@kindex RET (emms-browser)
@findex emms-browser-add-tracks
Add all tracks at point.

@item SPC
@kindex SPC (emms-browser)
@findex emms-browser-toggle-subitems
Show or hide (kill) subitems under the current line.

@item 1
@kindex 1 (emms-browser)
@findex emms-browser-collapse-all
Collapse everything.

@item 2
@kindex 2 (emms-browser)
@findex emms-browser-expand-to-level-2
Expand all top level items one level.

@item 3
@kindex 3 (emms-browser)
@findex emms-browser-expand-to-level-3
Expand all top level items two levels.

@item 4
@kindex 4 (emms-browser)
@findex emms-browser-expand-to-level-4
Expand all top level items three levels.

@item C
@kindex C (emms-browser)
@findex emms-browser-clear-playlist
Clear the playlist.

@item E
@kindex E (emms-browser)
@findex emms-browser-expand-all
Expand everything.

@item d
@kindex d (emms-browser)
@findex emms-browser-view-in-dired
View the current directory in dired.

@item q
@kindex q (emms-browser)
@findex emms-browser-bury-buffer
Bury the browser buffer.

@item r
@kindex r (emms-browser)
@findex emms-browser-goto-random
Jump to a random track.

@item /
@kindex / (emms-browser)
@findex emms-isearch-buffer
Isearch through the buffer.

@item <
@kindex < (emms-browser)
@findex emms-filters-previous-ring-filter
Redisplay with the previous filter.

@item >
@kindex > (emms-browser)
@findex emms-filters-next-ring-filter
Redisplay with the next filter.

@item ?
@kindex ? (emms-browser)
@findex describe-mode
See the Emacs documentation for the function.

@item C-/
@kindex C-/ (emms-browser)
@findex emms-playlist-mode-undo
Undo the previous playlist action.

@item <C-return>
@kindex <C-return> (emms-browser)
@findex emms-browser-add-tracks-and-play
Add all tracks at point, and play the first added track.

@item <backtab>
@kindex <backtab> (emms-browser)
@findex emms-browser-prev-non-track
Jump to the previous non-track element.

@item <tab>
@kindex <tab> (emms-browser)
@findex emms-browser-next-non-track
Jump to the next non-track element.

@item s A
@kindex s A (emms-browser)
@findex emms-browser-search-by-album
Search the collection by album.

@item s o
@kindex s o (emms-browser)
@findex emms-browser-search-by-albumartist
Search the collection by artist.

@item s a
@kindex s a (emms-browser)
@findex emms-browser-search-by-artist
Search the collection by artist.

@item s s
@kindex s s (emms-browser)
@findex emms-browser-search-by-names
Search the collection by names.

@item s t
@kindex s t (emms-browser)
@findex emms-browser-search-by-title
Search the collection by title.

@item s h
@kindex s h (emms-browser)
@findex emms-browser-show-searches
Show the currently active searches in the search cache.

@item b 1
@kindex b 1 (emms-browser)
@findex emms-browse-by-artist
Browse the collection by artist.

@item b 2
@kindex b 2 (emms-browser)
@findex emms-browse-by-album
Browse the collection by album.

@item b 3
@kindex b 3 (emms-browser)
@findex emms-browse-by-genre
Browse the collection by genre.

@item b 4
@kindex b 4 (emms-browser)
@findex emms-browse-by-year
Browse the collection by year.

@item b 5
@kindex b 5 (emms-browser)
@findex emms-browse-by-composer
Browse the collection by composer.

@item b 6
@kindex b 6 (emms-browser)
@findex emms-browse-by-performer
Browse the collection by performer.

@item b 7
@kindex b 5 (emms-browser)
@findex emms-browse-by-albumartist
Browse the collection by albumartist.

@item W a p
@kindex W a p (emms-browser)
@findex emms-browser-lookup-album-on-pitchfork
Lookup the album using Pitchfork.

@item W o w
@kindex W o w (emms-browser)
@findex emms-browser-lookup-albumartist-on-wikipedia
Lookup the album artist using Wikipedia.

@item W A w
@kindex W A w (emms-browser)
@findex emms-browser-lookup-artist-on-wikipedia
Lookup the artist using Wikipedia.

@item W c w
@kindex W c w (emms-browser)
@findex emms-browser-lookup-composer-on-wikipedia
Lookup the composer using Wikipedia.

@item W p w
@kindex W p w (emms-browser)
@findex emms-browser-lookup-performer-on-wikipedia
Lookup the performer using Wikipedia.

@item W a w
@kindex W a w (emms-browser)
@findex emms-browser-lookup-album-on-wikipedia
Lookup the album using Wikipedia.

@item +
@kindex + (emms-browser)
@findex emms-volume-raise
Raise the volume

@item -
@kindex - (emms-browser)
@findex emms-volume-lower
Lower the volume

@item i s
@kindex i s (emms-browser)
@findex emms-filters-status-print
Print what is known about the filters and cache

@item i c
@kindex i c (emms-browser)
@findex emms-filters-show-cache-stack
Show the current search cache stack.

@item i S
@kindex i S (emms-browser)
@findex emms-filters-show-cache-stash
Show the cache names in the stash.

@item i f
@kindex i f (emms-browser)
@findex emms-filters-show-filters
Show the filters there are.

@item i m
@kindex i m (emms-browser)
@findex emms-filters-show-filter-menu
Show the menu tree of filters as a menu.

@item i F
@kindex i F (emms-browser)
@findex emms-filters-show-filter-factories
Show the filter factories we have.

@item i r
@kindex i r (emms-browser)
@findex emms-filters-show-filter-ring
Show the filters in the filter ring.

@item f q
@kindex f q (emms-browser)
@findex emms-filters-pop
Pop the filter stack returning to last filter.

@item f r
@kindex f r
@findex emms-filters-swap (emms-browser)
Reverse the last two entries in the filter stack.

@item f R
@kindex f R (emms-browser)
@findex emms-filters-swap-pop ; rotate-eject, ,pop-previous
Reverse the last two entries in the filter stack, and pop the top one.

@item f S
@kindex f S (emms-browser)
@findex emms-filters-squash
Squash the filter stack, keep the top entry.

@item f k
@kindex f k (emms-browser)
@findex emms-filters-keep
Register the current filter into the list of filters for the session.
If @var{emms-filters-multi-filter-save-file} is set, append the filter definition there.

@item f h
@kindex f h (emms-browser)
@findex emms-filters-hard-filter
Build a cache from the current filter and push it to the cache stack.

@item f c
@kindex f c (emms-browser)
@findex emms-filters-clear
Clear the meta filter stack and the current filter function.

@item >
@kindex > (emms-browser)
@findex emms-filters-next-ring-filter
Move to the next filter in the filter ring.

@item <
@kindex < (emms-browser)
@findex emms-filters-previous-ring-filter
Move to the previous filter in the filter ring.

@item f !
@kindex f ! (emms-browser)
@findex emms-filters-clear-ring-filter
Set the ring filter to no filter.

@item f p
@kindex f p (emms-browser)
@findex emms-filters-push
Push a filter to the meta-filter stack.

@item f s
@kindex f s (emms-browser)
@findex emms-filters-smash
Clear the stack and select a filter to push to the stack.

@item f o
@kindex f o (emms-browser)
@findex emms-filters-or
Add a filter to the current/last filter list in the current filter.
Creates an OR.

@item f a
@kindex f a (emms-browser)
@findex emms-filters-and
Select a filter to start a new list of filters, creates an AND.

@item f n
@kindex f n (emms-browser)
@findex emms-filters-and-not
Select a filter to start a new list of filters, creates an AND-NOT list of filters.

@item c C
@kindex c C (emms-browser)
@findex emms-filters-clear-all
Reset the cache stack, the filter stack and the filter-ring.

@item c p
@kindex c p (emms-browser)
@findex emms-filters-push-cache
Cache/Store a filter and cache to the stack.

@item c z
@kindex c z (emms-browser)
@findex emms-filters-stash-pop-cache
Stash the current cache for later, pop it from the stack.

@item c Z
@kindex c Z (emms-browser)
@findex emms-filters-stash-cache
Stash the current cache for later.

@item c P
@kindex c P (emms-browser)
@findex emms-filters-pop-cache
Pop the current cache from the stack.

@item c h
@kindex c h (emms-browser)
@findex emms-filters-hard-filter
Create a cache from the current filter and push to the stack.

@item c r
@kindex c r (emms-browser)
@findex emms-filters-swap-cache
Swap the top two caches on the stack.

@item c q
@kindex c q (emms-browser)
@findex emms-filters-pop-cache
Pop the top cache from the stack.

@item c R
@kindex c R (emms-browser)
@findex emms-filters-swap-pop-cache
Swap the top two caches on the stack, then pop the top one.

@item c S
@kindex c S (emms-browser)
@findex emms-filters-squash-caches
Squash the cache stack, keep the top entry.

@item c c
@kindex c c (emms-browser)
@findex emms-filters-clear-caches
Clear all the caches down to the main cache.

@item s o
@kindex s o (emms-browser)
@findex emms-filters-search-by-albumartist
A fields search, quick one-shot for Album artist, push results to the cache stack.

@item s a
@kindex s a (emms-browser)
@findex mf-search-by-artist
A fields search, quick one-shot for Artist, push results to the cache stack.

@item s c
@kindex s c (emms-browser)
@findex emms-filters-search-by-composer
A fields search, quick one-shot for Composer, push results to the cache stack.

@item s p
@kindex s p (emms-browser)
@findex emms-filters-search-by-performer
A fields search, quick one-shot for Permformer, push results to the cache stack.

@item s A
@kindex s A (emms-browser)
@findex emms-filters-search-by-album
A fields search, quick one-shot for Album title, push results to the cache stack.

@item s t
@kindex s t (emms-browser)
@findex emms-filters-search-by-title
A fields search, quick one-shot for Song title, push results to the cache stack.

@item s T
@kindex s T (emms-browser)
@findex emms-filters-search-by-titles
A fields search, quick one-shot for Album and song titles, push results to the cache stack.

@item s n
@kindex s n (emms-browser)
@findex emms-filters-search-by-names
A fields search, quick one-shot for all names, push results to the cache stack.

@item s s
@kindex s s (emms-browser)
@findex emms-filters-search-by-names-and-title
A fields search, quick one-shot for all names and titles, push results to the cache stack.

@item s e
@kindex s e (emms-browser)
@findex emms-filters-search-by-all-text
A fields search, quick one-shot in all text fields, push results to the cache stack.

@end table

@node Displaying Covers
@section Displaying Covers

The browser will attempt to display cover images if they're
available.

Customize @var{emms-browser-covers} to configure how EMMS should retrieve the
covers.

By default it looks for images @file{cover_small.jpg}, @file{cover_med.jpg},
etc. Note that you'll probably want to resize your existing covers to particular
sizes. Suggested sizes are 100x100 for small, and 200x200 for medium.

The above behaviour demands manual processing on behalf of the user.  Instead,
you might prefer to automate the process by setting @var{emms-browser-covers} to
'emms-browser-cache-thumbnail': covers matching 'emms-browser-thumbnail-filter'
will be automatically resized if necessary and cached to
@var{emms-browser-thumbnail-directory}.  The cache gets automatically updated
upon change in the source folder.

Customize @var{emms-browser-covers-file-extensions} to include or exclude
specific extensions.

'emms-browser-cache-thumbnail' might be everytime a cover is queried, so
to help with performance you can also set @var{emms-browser-covers} to
'emms-browser-cache-thumbnail-async'.  The latter is like the former
except that it caches queries: every subsequent query will be much
faster.  The drawback is that it won't see changes made to covers after
the first query.  To force-refresh the thumbnail cache, you can run
'emms-browser-clear-cache-hash'.

Also, Emacs by default will jump around a lot when scrolling a buffer
with images. In order to prevent that, you can set
@var{scroll-up-aggressively} and @var{scroll-down-aggressively} to the
number ``0.0''.

To show a 'no cover' image for albums which don't have a cover, add
the following code to your .emacs:

@lisp
(setq emms-browser-default-covers
  (list "/path/to/cover_small.jpg" nil nil)
@end lisp

The medium and large images can be set as well.

You can download an example @uref{http://repose.cx/cover_small.jpg,
`no cover' image}.



@node Changing Looks
@section Changing Looks

The Browser's look can be customised. You can change the way the tree
structure looks, the display format and display faces.

@subheading Changing Tree Structure

You can change the way the tree is displayed by setting the value of
@var{emms-browser-tree-node-map}

@lisp
(setq emms-browser-tree-node-map emms-browser-tree-node-map-default)
@end lisp

The node map specifies the tree as an alist.
Follow the chain of fields from the starting browse type
to see how the browser tree will be built. ie. Starting with
album artist yields a tree with album artist, artist and album as nodes.

@lisp
(defvar emms-browser-tree-node-map-default
      '((info-albumartist . info-artist)
        (info-artist      . info-album)
        (info-composer    . info-album)
        (info-performer   . info-album)
        (info-album       . info-title)
        (info-genre       . info-artist)
        (info-year        . info-artist)))
@end lisp


The following code displays artist->track instead of
artist->album->track when you switch to the 'singles' filter:

@lisp
(defadvice emms-browser-next-mapping-type
                                (after no-album (current-mapping))
  (when (eq ad-return-value 'info-album)
    (setq ad-return-value 'info-title)))
@end lisp

@lisp
(defun toggle-album-display ()
  (if (string= emms-browser-current-filter-name "singles")
      (ad-activate 'emms-browser-next-mapping-type)
    (ad-deactivate 'emms-browser-next-mapping-type)))

;; Deprecated use the emms-filters hook instead.
;; (add-hook 'emms-browser-filter-changed-hook 'toggle-album-display)
(add-hook 'emms-filters-filter-changed-hook 'toggle-album-display)
@end lisp

Furthermore, you can customize
@var{emms-browser-get-track-field-function} to choose which the metadata
fields used for the different tree nodes (@code{'info-artist},
@code{info-year}, etc.).  For instance, you can choose whether to
organize the tree by artist, album artist or performer.

@subheading Changing Display Format

Format strings govern the way items are displayed in the browser and
playlist. You can customize these if you wish.

@var{emms-browser-default-format} controls the format to use when no
other format has been explicitly defined. By default, only track and
albums deviate from the default.

To customise the format of a particular type, find the name of the
field you want to use (eg `info-artist', `info-title', etc), and
insert that into emms-browser-<type>-format or
emms-browser-playlist-<type>-format. For example, if you wanted to
remove track numbers from tracks in both the browser and playlist, you
could do:

@lisp
(defvar emms-browser-info-title-format "%i%n")
(defvar emms-browser-playlist-info-title-format
  emms-browser-info-title-format)
@end lisp

The format specifiers available include:

@itemize @w{}

@item
%i    indent relative to the current level

@item
%n    the value of the item - eg -info-artist might be ``pink floyd''

@item
%y    the album year

@item
%A    the album name

@item
%a    the artist name of the track

%o    the album artist name
@item

@item
%t    the title of the track

@item
%o    the genre of the track

@item
%T    the track number

@item
%cS   a small album cover

@item
%cM   a medium album cover

@item
%cL   a big album cover
@end itemize

Note that if you use track-related items like %t, it will take the
data from the first track.

@subheading Changing Display Faces

The faces used to display the various fields are also customizable.
They are in the format emms-browser-<type>-face, where type is one of
"year/genre", "artist", "album" or "track". Note that faces lack the
initial "info-" part. For example, to change the artist face, type M-x
@command{customize-face} @command{emms-browser-artist-face}.

@node Filtering Tracks - deprecated
@section Filtering Tracks - deprecated

Note that these are the directions for creating filters from the browser
API which now works through the Emms-filters system.

The Emms-filter system obsoletes this method of creating filters.
However, it is still valid, and will work if you have filters defined
in this way.

It is recommended that the new filter system is used directly rather
than building filters in this way.

If you want to display a subset of your collection (such as a
directory of 80s music, only avi files, etc.) then you can extend the
Browser by defining ``filters''.

Show everything:

@lisp
(emms-browser-make-filter "all" 'ignore)
@end lisp

Set "all" as the default filter:

@lisp
(emms-browser-set-filter (assoc "all" emms-browser-filters))
@end lisp

Show all files (no streamlists, etc):

@lisp
(emms-browser-make-filter
 "all-files" (emms-browser-filter-only-type 'file))
@end lisp

Show only tracks in one folder:

@lisp
(emms-browser-make-filter
 "80s" (emms-browser-filter-only-dir "~/Mp3s/80s"))
@end lisp

Show all tracks played in the last month:

@lisp
(emms-browser-make-filter
 "last-month" (emms-browser-filter-only-recent 30))
@end lisp

After executing the above commands, you can use M-x
emms-browser-show-all, emms-browser-show-80s, etc to toggle between
different collections. Alternatively you can use '<' and '>' to cycle
through the available filters.

The second argument to make-filter is a function which returns t if a
single track should be filtered. You can write your own filter
functions to check the type of a file, etc.

Show only tracks not played in the last year:

@lisp
(emms-browser-make-filter "not-played"
 (lambda (track)
  (not (funcall (emms-browser-filter-only-recent 365) track))))
@end lisp

Show all files that are not in the pending directory:

@lisp
(emms-browser-make-filter
 "all"
 (lambda (track)
   (or
    (funcall (emms-browser-filter-only-type 'file) track)
    (not (funcall
          (emms-browser-filter-only-dir "~/Media/pending") track)))))
@end lisp


@c -------------------------------------------------------------------
@node The Filter System
@chapter The Filter System

The filter system allows you to filter the metadata cache in order search
and narrow your track data. It is based on a very powerful interactive
system consistenting of filter and cache stacks which allow
the creation and manipulation of complex filters and results caches.

The Filter system is defined in @file{emms-filters.el} and is included as
part of the Emms-Browser.

Emms-Filters allows you to filter and search the metadata cache.
This manages the search and filter functionalities of emms-browser.

@menu
* Filters and Searches::   A simple overview of the filter system.
* Backward Compatibility:: Backward compatibility with the Emms Browser.
* Filter Components::      Definitions of basic terminology used by the filter system.
* Filter Factories::       Defining filter factories.
* Factory Registration::   Registering Factories and using the prompting system.
* Defined Factories::      The built-in factories available
* Defining Filters::       Defining filters.
* The Filter Stack::       The filter stack, how it works, how to use it.
* The Cache Stack::        The cache stack, how to use it.
* Showing State::          Showing the current state of the filter system.
@end menu

@node Filters and Searches
@section Filters and Searches

There is little difference between filtering and searching. Searching
simply results in a data-cache which is smaller than the original.

The filter system has a cache stack where cached results are kept. All
subsequent filters and searches use the most current cache.

Filtering results in a rendered view for a subset of what is in the
data-cache. Complex filters are built interactively on a filter stack
by combining existing filters and interactively created filters.

A small group of filter factories are used to create filter functions
which are defined entirely as data. Those filters can be combined with
each other and with interactively created filters on the filter stack
with OR, AND, as well as AND-NOT. These more complex filters may also
be saved and coded entirely as data. In addition the filter stack has
various commands to manipulate it. Pop, swap, swap-pop, squash and clear,
among others.

For the concept of searches there is a search cache stack which is a
stack of emms-cache-db hash tables. The emms-cache-db is always present at
the base of this stack. Any filtered result may be pushed to this stack
at any time. Filters always operate against the cache at the top of the
stack. A cache may be stashed for later, and the usual stack manipulation
functions exist. Pop, swap, swap-pop, squash, clear, stash, and push.

Factories define filters from data and interactively.
Factories are kept in a ring, and each has a ring of its filters.
Interactively creating a new filter adds it to the ring for the session.
Personal filter rings can also be easily added to the filter menu ring.

There is another filter ring, which can have any filters you like, and is
selectable with < and >.  The active filter on the ring combines with
the filter stack to show the rendered results.

@node Backward Compatibility
@section Backward Compatibility

Maintaining backward compatibily with the Emmms-browser's previous
functionality was a prime goal in creating the filter system. Very little
is left in common, but the Browser's search-by and filtering API remains
intact and continues to behave as before. Anyone who has made filter
functions will notice no change in behavior other than there is more
flexibility in using their functions.

The filter system replaces both emms-browser filters and search-by
functionalities. The Emms-browser API remains in place, however underneath
the API it uses the filter system for all of its purposes.

Emms-browser-make-filter and emms-browser-search-by use emms-filters
for their current functionality. The search-by functionality is quite
simple. Emulating the browser filters was more complicated and has a
thin compatibility layer in @file{emms-browser.el}.

In all cases, obtaining the same functionalities soley within emms-filters is
simpler and and more powerful.

Emms-browser-filter functions are specified to return an
inverted value. the old @command{emms-browser-make-filter}
had a slightly different mechanism from the filter system's
@command{emms-filters-make-filter}. emms-browser-make-filter has been modified to
pass its filters to the emms-filter system. Those filters will be properly
inverted and added to the known emms-filters-filters and to the emms-filters-filter-ring
which emulates the original browser filter ring. This provides a
seamless experience for previous users of emms-browser filtering. As
the @var{emms-filters-filter-ring} is functionally equivalent to the browser's
filter ring.

The browser's 'Search-by' was just one filter factory, which corresponds
to the filter system's 'fields search' factory, and searches are not
inverted. The only real difference between the browser's filter and a
search was that a filter was rendered and a search was saved to a hash
for subsequent filtering. Filters couldn't filter a search, and neither
could work against anything but the Emms-cache-db. The equivalent to the
emms-browser search-by is just a one shot interactive 'new fields-search'
filter factory that saves a cache and then removes itself.

Emms-Filters is agnostic about the renderer. Currently there has been a
lot of effor to maintain backward compatibity with the Emms-browser as
its functionality was replaced. There are the following hooks that any
renderer could use in order to leverage Emms-Filters.

To maintain independence there are three hook variables which allow
emms-filters to interact with the Emms-Browsers functionality.

The first is a defcustom hook to mirror the browser's deprecated hook
of the same name.
The second hook happens just after, and is for any renderer
that wishes to re-render when a filter changes.
The third hook is to tell any renderer to expand its render if there is
a filter or cache stack entry present.

This a defcustom hook that is run anytime the filters change
@var{emms-filters-filter-changed-hook}

@lisp
(add-hook 'emms-filters-filter-changed-hook 'my-filters-have-changed-function)
@end lisp

The following two hooks are for the renderers which is currently
just the Emms-Browser. These hooks are the mechanism used to
actually filter and render the tracks.

When the filter or cache changes Emms-Filters needs to
tell the renderer to re-build its hash and display it.
For this purpose there is another hook, the
@var{emms-filters-make-and-render-hash-hook}.

The Emms-browser function for this is emms-browse-by.
This function applies the filters, creates a hash,
and then populates and renders a tree of data.
@lisp
(add-hook 'emms-filters-make-and-render-hash-hook 'emms-browse-by)
@end lisp

The last hook is the @var{emms-filters-expand-render-hook}.
This is just so that Emms-Filters can tell the renderer to
expand its tree when there is a filter or cache stack present
and something has changed.
For Emms-Browser this is the function emms-browser-expand-all

@lisp
;; (add-hook 'emms-filters-expand-render-hook 'emms-browser-expand-all)
@end lisp

The filter system is much more powerful than the previous system of
filtering and searching and is much easier to use both in code and interactively
while searching your tracks.

Here is a summary of differences and features of the filter system.

@itemize @bullet
@item Filters, no matter the complexity, are defined entirely as data.
@item Filters can be combined with AND, OR as well as AND-NOT.
@item Filters return true if they match the tracks.
@item Filters are lambda functions created with factories from data.
@item There is no difference between a search function and a filter function.
@item The factory should wrap the lambda in a let with lexical-binding t.
@item The factories and the filters must both be registered with Emms-filters.
@item Registered factories have a built in interactive prompting system.
@item Any results can be pushed to the cache stack for future filters and searches.
@item Complex filters are created interactively on the filter stack.
@item Searches are interactively created filters which leave a cache on the stack.
@item Interactively created filters can be saved as data for later use.
@item Interactively created filters remain in the filter selection menu for the session.
@end itemize

@node Filter Components
@section Filter Components
-------------------------------------------------------------------
The filter system consists of a few different mechanisms.
There are factories to make filters. There is the filter stack
to manage the creation and use of filters. Filters can be made of filters.

There is the cache stack to handle the saving of a set of filtered results
into a reduced database cache for subsequent filters.

There is the filter ring for quickly switching between commonly used filters.
This filter is combined with the current filter stack to render results.

@itemize @bullet
@item Filter Factories - To make filter functions.
@item Filters          - Defined as data. Dynamically created lambda functions.
@item Filter menu      - A customizable ring of factories and their rings of filters.
@item Multi-filter     - A filter factory to create filters made of filters.
@item Meta-filter      - A multi-filter data definition.
@item The filter stack - A meta-filter manipulator and multi-filter creator.
@item The cache stack  - A stack of database caches.
@item The filter ring  - A subset of convenient to use filters.
@end itemize

@node Filter Factories
@section Filter Factories
-------------------------------------------------------------------
Filter factories make filters which are simply test functions which
take a track and return true or false.

Factories are registered with the Emms-filter system so that they have
names that can be referenced later. Additionally, registration includes a
prompt and parameter definition. This allows the Emms-filters prompting
system to provide an interactive interface to any filter factory in
order to create new filters at any time.

Filter factories depend upon lexical context of their parameters. In
order to have data values that stick after function creation there
is let with lexical-binding to ensure the factory behaves as expected.
This transfers the values to local values and uses them as normal
within the returned #'(lambda (track)...) anonymous function.

As an example, here is the generic field-compare function.
It takes an operator function, a field name and the value to compare.
This single function can be a new factory for any data field
using any comparison function we would like.

@lisp
(defun emms-filters-make-filter-field-compare (operator-func field compare-val)
  "Make a filter that compares FIELD to COMPARE-VALUE with OPERATOR-FUNC.
Works for number fields and string fields provided the appropriate
type match between values and the comparison function. Partials can
easily make more specific factory functions from this one."
  (let ((local-operator operator-func)
                (local-field field)
                (local-compare-val compare-val))
    #'(lambda (track)
        (let ((track-val (emms-track-get track local-field)))
          (and
           track-val
           (funcall local-operator local-compare-val track-val))))))
@end lisp


@node Factory Registration
@section Factory Registration

Registering a factory associates a name, a function and a list of prompt
definitions so that we may create filters interactively by name. The
prompting system will coerce the values given to the specified type
providing select lists as indicated.

The factory prompt data is used to interactively create new filters.
A prompt is  (prompt (type . select-list)) if there is no
select list we read the value and coerce the value to the
type as needed.

These are the known coercion types.

@itemize @bullet
@item :number
@item :string
@item :list
@item :symbol
@item :function
@end itemize

Here is the Genre Factory which is actually made from the field-compare
factory. This is a common pattern to create a simpler factory from a
more complex one. It is simply a partial that is registered directly
with a different set of prompts. In this case 'Genre:' is the prompt
and it is expected to be a string.

@lisp
(emms-filters-register-filter-factory
 "Genre"
 (apply-partially 'emms-filters-make-filter-field-compare
                  'string-equal-ignore-case 'info-genre)
 '(("Genre: " (:string . nil))));;
@end lisp

The registration for the compare field factory is more complex because of
the prompting for all the parameters. By changing just the registration
name and the prompts we can create two factories, one for numbers and
one for strings. Note the use of the ` and , to force the select lists
to resolve within the lambda.

Here is the registration for the number field compare factory. The
operator function has a select list of number comparison functions. The
field name has a select list of known numeric field names and the value
to compare must be a number and will be coerced as needed.

@lisp
(emms-filters-register-filter-factory "Number field compare"
                             'emms-filters-make-filter-field-compare
                             ;; prompts
                             `(("Compare Function: "
                                (:function . ,emms-filters-number-compare-functions))
                               ("Field name: "
                                (:symbol . ,emms-filters-number-field-names))
                               ("Compare to: "
                                (:number . nil))))
@end lisp


@node Defined Factories
@section Defined Factories

There are a number of defined factories derived from just a few functions.
Most common filters can be easily made with these.
There are a few predifined filters, but that has been kept to a minimum
as filters can be a very personal thing. There are already filters for every
track type and there many common genres and year range filters by decade.

Filter factories like artist, album artist, composer, Names, etc.
are all just specialized field compare or the fields search factories.

Filter factories include the following.

@itemize @bullet
@item Album
@item Album-artist
@item All text fields
@item Artist
@item Artists
@item Artists and composer
@item Composer
@item Directory
@item Duration less
@item Duration more
@item Fields search
@item Genre
@item Greater than Year
@item Less than Year
@item Multi-filter
@item Names
@item Names and titles
@item Not played since
@item Notes
@item Number field compare
@item Orchestra
@item Performer
@item Played since
@item String field compare
@item Title
@item Titles
@item Track type
@item Year range
@end itemize


@node Defining Filters
@section Defining Filters

Making a filter in elisp from a factory is easy.

(emms-filters-make-filter <Factory Name> <Filter Name> <Factory Parameters>)

The Genre Factory takes one string argument.
@lisp
(emms-filters-make-filter "Genre" "My Genre filter" "Somevalue")
@end lisp

Make a lot of filters at once with emms-filters-make-filters.

@lisp
(emms-filters-make-filters '(("Genre" "Waltz"      "waltz")
                    ("Genre" "Salsa"      "salsa")
                    ("Genre" "Blues"      "blues")
                    ("Genre" "Jazz"       "jazz")))
@end lisp

Filters can be easily created interactivly.
Just push a filter onto the stack with @command{emms-filters-push},
@command{emms-filters-and}, @command{emms-filters-or}, @command{emms-filters-and-not},
or @command{emms-filters-squash},
select 'new filter' then your factory and follow the prompts.

Filters are added by name to their respective factory's filter ring.
Here are some more complex filter definitions including some
Multi-filter definitions, or meta-filters which are simply lists
of filters by name, they are functionally equivalent to what
is being built by the filter stack.

@lisp
(setq tango-filters
      '(("Year range" "1900-1929" 1900 1929)
        ("Year range" "1929-1937" 1929 1937)

        ("Directory" "tangotunes" "tangotunesflac")

        ("Genre" "Vals"    "vals")
        ("Genre" "Tango"   "tango")
        ("Genre" "Milonga" "milonga")

        ("Multi-filter"
         "1900-1937"
         (("1900-1929" "1929-1937")))

        ("Multi-filter"
         "Vals | milonga"
         (("Vals" "Milonga")))

        ("Multi-filter"
         "Vals 1900-1929"
         (("Vals") ("1900-1929")))

        ("Multi-filter"
         "Not vals"
         ((:not "Vals")))

        ("Multi-filter"
         "Vals or milonga 1900-1937"
         (("Vals" "Milonga")
          ("1900-1929" "1929-1937")))
        ))

(emms-filters-make-filters tango-filters)
@end lisp

A new entry in the Factory ring along with it's filters
can also be easily added. This function deconstructs the definitions
to facilitate the ease of addition. It can also be made from a
simple list of names as well. The filters will appear both under their
respective factories, and under this new menu item 'Tango'.
They are not recreated, but simply listed by their names to be chosen.

@lisp
(emms-filters-add-filter-menu-from-filter-list "Tango" tango-filters)
@end lisp

Here is the easiest way to make the filter ring as used by the Browser.
It is just a list of filter names.

@lisp
(emms-filters-make-filter-ring '("Tango" "Vals" "Milonga"))
@end lisp

The filter menu is automatically constructed as a ring of factory names
as 'folders' that have a ring of filters. This filter menu tree can be
added to in various ways. 'Keeping' a filter on the filter stack will
temporarily add the multi-filter defined by the filter stack to the
multi-filter ring.

There are other ways to add to the filter menu tree.
@command{emms-filters-add-to-filter-menu-from-filter-list} is used to deconstruct
a variable holding filter defintions as in the example above in order
to create a new ring in the menu tree.

In turn that function uses @command{emms-filters-add-to-filter-menu} which takes
a folder name and a filter or list of filters to place in the ring.
The function @command{emms-filters-add-name-to-filter-menu} will add a filter by
name to an existing filter folder/factory.

It is also possible to view the filter menu tree as a message with
@command{emms-filters-show-filter-menu}


@node The Filter Stack
@section The Filter Stack

The filter stack builds more complex filters as you push filters to
it. Adding to the filter or replacing it with another push creates a new
meta-filter and it's multi-filter function to the filter stack. To return
to the previous filter simply pop the stack. Each change to the stack, creates
a meta-filter and it's corresponding constructed meta-filter. Any change
results in a new 'current' multi-filter. The filters are represesented
as are constructed names of the filters that created it.

The filter stack uses meta-filters in a cons
like this; (name . meta-filter).
Filter names for meta-filters can be easily constructed from the filters
they are made from. They aren't short but they work well enough.

To use a filter, @command{emms-filters-push} it to create a new current filter
on the stack. It will become a meta-filter on the filter stack and the
current active filter will be a multi-filter version of it. The functions
required to construct the current multi-filter are resolved at this time
in a new multi-filter lambda function.

The filter ring works independently of the filter stack. Each re-filtering
of tracks uses the current ring filter and the current filter together.

A filter on the stack can be 'kept'. The function @command{emms-filters-keep}
will create and register a multi-filter of the current filter, adding
it to the multi-filter menu. This only lasts until the current Emacs
session ends. If @var{emms-filters-multi-filter-save-file} is set, keep will
append a usable filter definition to the file for reuse as you wish.

Other commands for manipulating the stack are listed here. Most
should be self explanatory, Squash clears the stack, leaving the
topmost filter. Smash is a clear followed by a push.

@itemize @bullet
@item @command{emms-filters-pop}
@item @command{emms-filters-squash}
@item @command{emms-filters-smash}
@item @command{emms-filters-clear}
@item @command{emms-filters-swap}
@item @command{emms-filters-swap-pop}
@item @command{emms-filters-keep}
@end itemize

An initial filter can be created with
@command{emms-filters-push} or @command{emms-filters-smash} which is a clear followed by a push.

Adding to the filter stack is done with
@command{emms-filters-and}, @command{emms-filters-or}, @command{emms-filters-and-not},

@node The Cache Stack
@section The Cache Stack

The cache stack is a simply a stack of emms-cache-db style hash tables.
The full emms-cache-db is at the base of the stack and is always there.
Each entry in the stack is a subset of the cache below it as a result
of filtering. The stack entry names are constructed from the filters
which created them.

Filtering and displaying of tracks is done against the top cache on the stack.

The function, @command{emms-filters-hard-filter} is the most common way to create
an entry on the cache stack. It creates a cache from the current filter
and cache, and pushes it to the stack. This does render the current filter
as non-effective, so it can be cleared, or continue to grow depending
on your desires.  It can be useful to just keep going so that returning
to the previous state is possible.

One of the driving forces with creating cache entries was the way that
the Emms-browser has always done searching.  To this end, additional
functionality was created to better emulate the browser's way of doing
things. However the cache stack provides a lot of flexibility and power
in how you navigate and search your music. Simply being able to repeatedly
search and narrow the data is quite powerful all by itself.

One-Shot filtering allows behavioral backward compatibility with the
browser. One shots were created to emulate the browser's behavior of
creating a subset cache from search-by. One shots push a filter, save
to the cache stack and pop the filter, leaving only the cache.

Using @command{emms-filters-one-shot} will push a filter, push a cache,
then pop the filter. It will interactively prompt for a factory, the
filter, and then the filter parameters to create a filter if none is
given. @command{emms-filters-quick-one-shot} takes a factory name, and invokes
the interactive creation of a new filter with that factory directly.
The command @command{emms-filters-fields-search-quick-one-shot} is a one-shot
using the fields-search filter factory, while adding to the fields-search
ring in the filter menu-tree. The fields-search factory is the filter
system's way of emulating browser's search-by functionality.

These functions effectively allow the emulation of the browser's search
behavior of quickly prompting, filtering and pushing a cache followed
by a pop of the filter used. By the grace of that, simple wrapper
functions for each of the browser's search functions were created
using emms-filters-quick-one-shot. These functions are named after their browser
equivalents as emms-filters-search-by-<field-names>. The browser search functions
now call these filter system functions directly.

Manipulating the cache stack is similar to manipulating the filter stack,
The usual stack commands are:
@itemize @bullet
@item @command{emms-filters-pop-cache}
@item @command{emms-filters-squash-caches}
@item @command{emms-filters-clear-caches}
@item @command{emms-filters-swap-cache}
@item @command{emms-filters-swap-pop-cache}
@item @command{emms-filters-push-cache}
@item @command{emms-filters-stash-cache}
@item @command{emms-filters-stash-pop-cache}
@end itemize

The functions @command{emms-filters-push-cache}, @command{emms-filters-stash-cache} and
@command{emms-filters-stash-pop-cache} allow for a cache to be stashed and then
later pushed back to the stack. The current cache on the stack can be
stashed at anytime. The stashed caches will be a selection ring
for @command{emms-filters-push-cache}.


@node Showing State
@section Showing State

There are various functions that enable a view of all that is going
on within the filter system. At the top level these are simply emacs
messages which can be easily dismissed. Just below them, are equivalent
functions that give formatted string versions for use as you like.

The registered filter factories can be shown with
@command{emms-filters-show-filter-factories}, the registered
filters can be shown with @command{emms-filters-show-filters}.
The @command{emms-filters-show-filter-menu} will show the current filter menu tree.

The current filter ring can be shown with @command{emms-filters-show-filter-ring}
and the filter stack can be shown with  @command{emms-filters-current-meta-filter}.

In code, the current filter name can be obtained with the
@command{emms-filters-current-meta-filter-name}.
The current ring filter name can be obtained with
@command{emms-filters-current-ring-filter-name}

Showing the cache stack is done with @command{emms-filters-show-cache-stack}.
Any stashed caches can be seen with @command{emms-filters-show-cache-stash}
which will also appear in the menu invoked by @command{emms-filters-push-cache}.

Finally for a more complete report of the system use @command{emms-filters-status-print}
which is a message of the formatted string given by @command{emms-filters-status}.

In turn, the @command{emms-filters-status} is simply a format of the following four
functions that give formatted strings of the moving parts of the filter system.

@itemize @bullet
@item @command{emms-filters-current-ring-filter}
@item @command{emms-filters-current-meta-filter}
@item @command{emms-filters-format-stack}
@item @command{emms-filters-format-cache-stack}
@end itemize


@c -------------------------------------------------------------------
@node Sorting Playlists
@chapter Sorting Playlists

@cindex sort
@cindex track order

The `emms-playlist-sort' module, defined in the
@file{emms-playlist-sort.el} package provides functions for sorting
Emms playlists, as well as keyboard shortcuts for invoking the
functions in the playlist buffer. Most of the functions will sort in
reverse order if the command is preceded by a
prefix. `emms-playlist-sort' can be loaded by invoking:

@lisp
(require 'emms-playlist-sort)
@end lisp

@defun emms-playlist-sort-by-info-artist
Sort by artist name.
@end defun

@defun emms-playlist-sort-by-info-albumartist
Sort by albumartist name.
@end defun

@defun emms-playlist-sort-by-play-count
Sort by number of times the track has been played.
@end defun

@defun emms-playlist-sort-by-info-album
Sort by album name.
@end defun

@defun emms-playlist-sort-by-last-played
Sort by time the track was played last.
@end defun

@defun emms-playlist-sort-by-info-title
Sort by track title.
@end defun

@defun emms-playlist-sort-by-file-extension
Sort by filename extension.
@end defun

@defun emms-playlist-sort-by-info-performer
Sort by performer name.
@end defun

@defun emms-playlist-sort-by-info-year
Sort by year.
@end defun

@defun emms-playlist-sort-by-info-note
Sort by track notes.
@end defun

@defun emms-playlist-sort-by-info-composer
Sort by composer.
@end defun

@defun emms-playlist-sort-by-name
Sort by track name.
@end defun

@defun emms-playlist-sort-by-file-mtime
Sort by file mtime.
@end defun

@defun emms-playlist-sort-by-random
Sort randomly. Alias for `emms-shuffle'.
@end defun

@defun emms-playlist-shuffle
Alias for `emms-playlist-sort-by-random' and `emms-shuffle'.
@end defun


@c -------------------------------------------------------------------
@node Persistent Playlists
@chapter Persistent Playlists

The Emms module @file{emms-history.el} makes playlists persistent over
emacs sessions.  To make use of this feature put this into your
~/.emacs.

@lisp
(require 'emms-history)
@end lisp

When you kill emacs all playlists will be saved in the file given by the
variable:

@defopt emms-history-file
The file to save playlists in.  It defaults to
"~/.emacs.d/emms-history".
@end defopt

After you started up emacs again, you can restore all saved playlists
with this function.

@defun emms-history-load
Restore all playlists in `emms-history-file'.
@end defun

If that should be done automatically on each startup, put these lines
into your ~/.emacs.

@lisp
(require 'emms-history)
(emms-history-load)
@end lisp

Normally @code{emms-history} only restores playlists.  If you want it to
start playback afterwards, you can tweak this variable.

@defopt emms-history-start-playing
If non-nil emms starts playing the current track after
`emms-history-load' was invoked.  The default value is nil.
@end defopt


@c -------------------------------------------------------------------
@node Editing Tracks
@chapter Editing Tracks

@cindex track editor

Using @file{emms-tag-editor.el}, emms can set tag informations of tracks
and write them back to the file with the help of external programs, such
as `mid3v2' and `vorbiscomment'.

Use the keybinding @kbd{E} to edit the tags of track under point in the
playlist or all marked tracks (@pxref{Markable Playlists} for how to
mark tracks).  The track's tag informations are listed in a special
buffer `*Emms-TAGS*' in text format.  Field names are marked in bold
face and are not editable.  Any tag information is placed behind an
equal sign and is changable.  A special field `name' is the track's file
name.  If any change is made in this field, the track's file will be
renamed to the new name.  When you finished editing the tag infos use
@kbd{C-c C-c} (which calls @code{emms-tag-editor-submit-and-exit}) to
submit the changes and close the `*Emms-TAGS*' buffer.

There are a few commands to perform changes on all tracks.

@defun emms-tag-editor-set-all tag value
Set TAG to VALUE in all tracks.

If transient-mark-mode is turned on, you can apply the command to a
selected region.

If `transient-mark-mode' is on and the mark is active, the changes will
only take effect on the tracks in the region.
@end defun

@defun emms-tag-editor-replace-in-tag tag from to
Query and replace text in selected TAG.

For example, if the info-title tag is selected, then only perform
replacement in title tags.

If `transient-mark-mode' is on and the mark is active, the changes will
only take effect on the tracks in the region.
@end defun

@defun emms-tag-editor-transpose-tag tag1 tag2
Transpose value of TAG1 and TAG2.

If `transient-mark-mode' is on and the mark is active, the changes will
only take effect on the tracks in the region.
@end defun

@defun emms-tag-editor-submit arg
Make modified tags take affect.

With prefix argument, bury the tag edit buffer.
@end defun

If you want to extend the tag editor to work with file formats other
than `mp3' and `ogg', have a look at these variables.

@defvr {Variable} emms-tag-editor-formats
This variable determine how to insert track fields to
`emms-tag-editor-edit-buffer'.  Emms tag info editable fields is usually
determined by the extension of track name.  The variable
`emms-tag-editor-tags' contains all tags that emms track may have.  A
single charactar is assigned to the tag to make the
`emms-tag-editor-formats' easier to generate.
@end defvr

@defvr {Variable} emms-tag-editor-tagfile-functions
To write tags to track file, an extern program should specified in this
variable.
@end defvr

@heading Renaming Files

The tag editor is also capable to rename the file of the track at point
or all files of the marked tracks according to the value this variable.

@defopt emms-tag-editor-rename-format
When `emms-tag-editor-rename' is invoked the track's file will be
renamed according this format specification.  The file extension will be
added automatically.

It uses the format specs defined in @code{emms-tag-editor-tags}.

The default value is "%a - %l - %n - %t", so that files are named

  <Artist> - <Album> - <Tracknumber> - <Title>.<extension>

after renaming.
@end defopt

To perform the renaming put point on the track you want to rename or
mark some tracks.  Then hit @kbd{R} which calls this function:

@defun emms-tag-editor-rename
Rename the file corresponding to track at point or all marked tracks
according to the value of @code{emms-tag-editor-rename-format}.
@end defun


@c -------------------------------------------------------------------
@node Emms Mode Line
@chapter Emms Mode Line

@cindex mode line
@cindex display emms information

We can display information about the currenty playing track on the
Emacs mode line using the package `emms-mode-line' which is provided
by the file @file{emms-mode-line.el}.

To activate this feature invoke:

@lisp
(require 'emms-mode-line)
(emms-mode-line 1)
@end lisp

It is also possible to display the amount of time a track has been
playing. This feature is defined in the `emms-playing-time' package
which is provided by the file @file{emms-playing-time.el}.

To use this feature invoke:

@lisp
(require 'emms-playing-time)
(emms-playing-time 1)
@end lisp

A graphical icon can be displayed in the modeline when Emms is
playing. This feature is provided by @file{emms-mode-line-icon.el}. To
enable invoke the following and make sure that
@var{emms-mode-line-icon-enabled-p} is set to a non-nil value:

@lisp
(require emms-mode-line-icon)
@end lisp

Note: `(emms-playing-time -1)' will disable emms-playing-time module
completely, and is not recommended. (since some other emms modules may
rely on it)

Instead, to toggle displaying playing time on mode line, one could call
`emms-playing-time-enable-display' and
`emms-playing-time-disable-display'."

@defun emms-playing-time-enable-display
Display playing time on mode line.
@end defun

@defun emms-playing-time-disable-display
Remove playing time from mode line.
@end defun


@c -------------------------------------------------------------------
@node Limiting
@chapter Limiting

@cindex limiting
@cindex playlist

The package `emms-playlist-limit', provided by
@file{emms-playlist-limit.el}, allows creating a new
playlist derived from the playlist in the current
buffer. For instance, it is possible to create a new
playlist containing only a certain artist or genre from the
playlist in the current buffer.

If the playlist in the current buffer is the emms current
playlist then the derived playlist becomes current.

@table @kbd
@item / a
@kindex / a
@findex emms-playlist-limit-to-info-artist
Create a new playlist buffer and populate it with tracks
whose artist info field matches the given regular
expression (default: the artist info field of the
track at point).

@item / A
@kindex / A
@findex emms-playlist-limit-to-info-albumartist
Create a new playlist buffer and populate it with tracks
whose album artist info field matches the given regular
expression (default: the album artist info field of the
track at point).

@item / b
@kindex / b
@findex emms-playlist-limit-to-info-album
Create a new playlist buffer and populate it with tracks
whose album info field matches the given regular
expression (default: the album info field of the
track at point).

@item / c
@kindex / c
@findex emms-playlist-limit-to-info-composer
Create a new playlist buffer and populate it with tracks
whose composer info field matches the given regular
expression (default: the composer info field of the
track at point).

@item / d
@kindex / d
@findex emms-playlist-limit-to-description
Create a new playlist buffer and populate it with tracks
whose track description matches the given regular
expression (default: the track description of the
track at point).

@item / g
@kindex / g
@findex emms-playlist-limit-to-info-genre
Create a new playlist buffer and populate it with tracks
whose genre info field matches the given regular
expression (default: the genre info field of the
track at point).

@item / n
@kindex / n
@findex emms-playlist-limit-to-name
Create a new playlist buffer and populate it with tracks
whose name matches the given regular expression (default:
the name of the track at point).

@item / p
@kindex / p
@findex emms-playlist-limit-to-info-performer
Create a new playlist buffer and populate it with tracks
whose performer info field matches the given regular
expression (default: the performer info field of the
track at point).

@item / t
@kindex / t
@findex emms-playlist-limit-to-info-title
Create a new playlist buffer and populate it with tracks
whose title info field matches the given regular
expression (default: the title info field of the
track at point).

@item / y
@kindex / y
@findex emms-playlist-limit-to-info-year
Create a new playlist buffer and populate it with tracks
whose year info field matches the given regular
expression (default: the year info field of the
track at point).

@item / /
@kindex / /
@findex emms-playlist-limit-to-all
Switch to the original playlist buffer (if it still exists).
@end table


@c -------------------------------------------------------------------
@node Music Player Daemon
@chapter Music Player Daemon

@cindex music player daemon
@cindex remote interface
@cindex mpd

Emms provides an interface to the @uref{http://www.musicpd.org/, Music
Player Daemon}(MusicPD) software. The package is called `emms-player-mpd' and
is provided by the file @file{emms-player-mpd.el}.

The advantages of using MusicPD as an Emms backend include the
following.

@itemize @bullet

@item minimal CPU usage

@item fast access of track information

@item optional crossfade
@end itemize

@subheading Setup

To load `emms-player-mpd' invoke:

@lisp
(require 'emms-player-mpd)
@end lisp

Set the variables @var{emms-player-mpd-server-name} and
@var{emms-player-mpd-server-port} to the location and port
(respectively) of your MusicPD server. For example:

@lisp
(setq emms-player-mpd-server-name "localhost")
(setq emms-player-mpd-server-port "6600")
@end lisp

If your MusicPD setup requires a password, you will to set
@var{emms-player-mpd-server-password} as follows.

@lisp
(setq emms-player-mpd-server-password "mypassword")
@end lisp

To get track information from MusicPD, invoke the following:

@lisp
(add-to-list 'emms-info-functions 'emms-info-mpd)
@end lisp

Adding `emms-player-mpd' to your Emms player list is accomplished by
invoking:

@lisp
(add-to-list 'emms-player-list 'emms-player-mpd)
@end lisp

Unless your MusicPD is configured to use absolute file names, you must
set the emms-player-mpd-music-directory variable to the value of
'music_directory' in your MusicPD configuration.  There are
additional options available as well, but the defaults should be
sufficient for most uses.

Once you've done the above, run the @kbd{M-x
emms-cache-set-from-mpd-all} command to fill the Emms cache with the
contents of your MusicPD database. The music in your MusicPD database
should then be accessible via the Emms browser.

You can set @var{emms-player-mpd-sync-playlist} to nil if your master
Emms playlist contains only stored playlists.

In order for Emms to synchronize track information correctly with
MusicPD, you must set the MusicPD server runtime 'consume' option to
'off'. This can be accomplished with the mpc command line MusicPD client
using the command @command{mpc consume off}.

@subheading Commands provided

@defun emms-player-mpd-connect
Connect to MusicPD and retrieve its current playlist. Afterward, the
status of MusicPD will be tracked.
@end defun

@defun emms-player-mpd-disconnect
Terminate the MusicPD client process and disconnect from MusicPD.
@end defun

@defun emms-player-mpd-show &optional insertp
Describe the current Emms track in the minibuffer. If INSERTP is
non-nil, insert the description into the current buffer instead. This
function uses @var{emms-show-format} to format the current track. It
differs from @command{emms-show} in that it asks MusicPD for the
current track, rather than Emms.
@end defun

@subsubheading Updating the MusicPD database

@defun emms-player-mpd-update-directory dir
Cause the tracks in DIR to be updated in the MusicPD database.
@end defun

@defun emms-player-mpd-update-all
Cause all tracks in the MusicPD music directory to be updated in
the MusicPD database.
@end defun

@subsubheading emms-cache.el integration

@defun emms-cache-set-from-mpd-directory dir
Dump all MusicPD data from DIR into the Emms cache.
This is useful to do when you have recently acquired new music.
@end defun

@defun emms-cache-set-from-mpd-all
Dump all MusicPD data into the Emms cache.
This is useful to do once, just before using emms-browser.el, in
order to prime the cache.
@end defun

@subsubheading emms-volume.el integration

To activate this, add the following to your .emacs.

@lisp
(require 'emms-volume)
(setq emms-volume-change-function 'emms-volume-mpd-change)
@end lisp


@c -------------------------------------------------------------------
@node Lyrics
@chapter Lyrics

@cindex lyrics

We can display the lyrics of a song in time with the music using the
`emms-lyrics' package provided by the file @file{emms-lyrics.el}.

The lyrics files should have the extention ``.lrc'', and can be placed
under either the same directory as the music files or
@var{emms-lyrics-dir}.

To add this feature we invoke:

@lisp
(require 'emms-lyrics)
(emms-lyrics 1)
@end lisp

Synchronized lyrics files can be obtained manually from various
sources, or fetched automatically for new tracks from an LRCLIB server
(@url{https://lrclib.net}) by adding the following function to
@var{emms-track-initialize-functions}:

@defun emms-lyrics-lrclib-get &optional track force interactive
Search for synchronized lyrics for @var{track} through LRCLIB’s API.
If @var{track} is omitted or nil, use the selected track in the
current playlist.
When used as a track initialization function, @var{track} is set to
the track being initialized.
The lyrics are saved in an ``.lrc'' file alongside the track, unless
the file already exists (in which case the search isn’t performed).
When called interactively (non-nil @var{interactive}), display
informative messages, and with prefix argument @var{force}, ask to
overwrite existing ``.lrc'' files.
@end defun

There are a number of variables we can set to define the way that
`emms-lyrics' behaves, we can set these directly or by using the
Customize feature in Emacs.

@defvr {User Option} emms-lyrics-display-on-minibuffer
If non-nil, display lyrics on minibuffer.
@end defvr

@defvr {User Option} emms-lyrics-display-on-modeline
If non-nil, display lyrics on modeline.
@end defvr

@defvr {User Option} emms-lyrics-dir
Local lyrics repository.
@command{emms-lyrics-find-lyric} will look for lyrics in current
directory(i.e., same as the music file) and this directory.
@end defvr

@defvr {User Option} emms-lyrics-display-format
Format for displaying lyrics. "%s" will be replaced by the lyrics
string.
@end defvr

@defvr {User Option} emms-lyrics-coding-system
Coding system used in the output of lyrics.
@end defvr

@defvr {User Option} emms-lyrics-scroll-p
Non-nil value will enable lyrics scrolling.
@end defvr

@defvr {User Option} emms-lyrics-scroll-timer-interval
Interval between scroller timers. The shorter, the faster.
@end defvr

@defvr {User Option} emms-lyrics-lrclib-url
Base URL for LRCLIB API requests.
@end defvr

We can control `emms-lyrics' with the help of the following functions:

@defun emms-lyrics-start
Start displaying lyrics.
@end defun

@defun emms-lyrics-stop
Stop displaying lyrics.
@end defun

@defun emms-lyrics-toggle-display-on-minibuffer
Toggle display lyrics on minibufer.
@end defun

@defun emms-lyrics-toggle-display-on-modeline
Toggle display lyrics on mode line.
@end defun

@defun emms-lyrics-enable
Enable displaying Emms lyrics.
@end defun

@defun emms-lyrics-disable
Disable displaying Emms lyrics.
@end defun

@defun emms-lyrics-toggle
Toggle displaying Emms lyrics.
@end defun


@c -------------------------------------------------------------------
@node Volume
@chapter Volume

@cindex volume

We can use the `emms-volume' package, as provided by the
@file{emms-volume.el} file, to manipulate the volume.

@defopt emms-volume-change-amount
The amount to use when raising or lowering the volume using the
emms-volume interface.

This should be a positive integer.
@end defopt

@defun emms-volume-raise
Increase the volume.
@end defun

@defun emms-volume-lower
Decrease the volume.
@end defun

If you feel like binding those two functions to global keys --- don't do
it or you'll miss the convenience of `emms-volume-minor-mode'. Instead,
bind the following two commands to some keys that you like.

@defun emms-volume-mode-plus
Raise volume and enable or extend the `emms-volume-minor-mode' timeout.
@end defun

@defun emms-volume-mode-minus
Lower volume and enable or extend the `emms-volume-minor-mode' timeout.
@end defun

Example:

@lisp
(global-set-key (kbd "C-c +") 'emms-volume-mode-plus)
(global-set-key (kbd "C-c -") 'emms-volume-mode-minus)
@end lisp

Whenever you use one of these keys or call these functions with
@kbd{M-x}, Emms will be put into `emms-volume-minor-mode' for a short
period defined by `emms-volume-mode-timeout'.

@defopt emms-volume-mode-timeout
The timeout in amount of seconds used by `emms-volume-minor-mode'.
@end defopt

In this interval you can raise/lower the volume simply by pressing
@kbd{+} or @kbd{-}, which will also reset the timer to its initial
value. So instead of pressing @kbd{C-c +} six times to increase volume
by six steps of @code{emms-volume-change-amount}, you would simply type
@kbd{C-c + + + + + +}.

Emms can change volume with amixer, mpd, PulseAudio and mixerctl out
of the box, see @var{emms-volume-change-function}.


@c -------------------------------------------------------------------
@node Streaming Audio
@chapter Streaming Audio

@cindex streaming audio
@cindex internet radio

Emms is a great way to play streaming audio and internet radio. It is
possible to add streaming playlists and URLs to any playlist, but Emms
also comes with a built-in, eclectic list of streaming audio
stations. @footnote{Emms has no affiliation of any kind with the
streaming audio stations included, nor is their inclusion an
endorsement of these stations. Instead, this is a collection of
stations submitted to the project over the years by people who enjoy
Emms. We hope you will enjoy them too, and invite you to send in your
suggestions to add to the list.}

The @file{emms-streams.el} package provides the command
@command{emms-streams}.

Invoking @command{emms-streams} will pull up an Emms playlist buffer
and populate it with the built-in list of streaming audio sources.

If you are using the mpv player, defined by @file{emms-player-mpv.el},
then you can display the currently streaming track title (if the
station provides that information) by configuring:

@lisp
  (customize-set-variable 'emms-player-mpv-update-metadata t)
@end lisp


@c -------------------------------------------------------------------
@node Radio Browser
@chapter Radio Browser

@cindex streaming audio
@cindex internet radio

We can find new internet radio stations to stream by
searching the database at
@url{https://www.radio-browser.info}.  The
@file{emms-radio-browser.el} package provides the following commands
to do this:

@defun emms-radio-browser-search-by-name
Prompts for a station NAME and returns a playlist of
matching streams.
@end defun

@defun emms-radio-browser-search-by-url
Prompts for a station URL and returns a playlist of
matching streams.
@end defun

@defun emms-radio-browser-full-search
Pops up a form to search by name, tags, country or language.
Returns a playlist of matching streams.
@end defun

To activate @file{emms-radio-browser.el}, do

@lisp
(require 'emms-radio-browser)
@end lisp

You will need the @file{transient.el} package to be installed (this is
built-in since emacs v28.1).

@c -------------------------------------------------------------------
@node APE / FLAC Commands
@chapter APE / FLAC Commands

Often, a single APE or FLAC file contains a complete album.  We can
still play next or previous track in the album with the help of
@file{emms-cue.el} package, provided there is a corresponding cue
sheet file.  This package also defines @code{emms-info-cueinfo} for
retreiving the track information for APE / FLAC itself.

To load @file{emms-cue.el}:

@lisp
(require 'emms-cue)
(add-to-list 'emms-info-functions 'emms-info-cueinfo)
@end lisp

@defun emms-cue-next
Play next track from .cue file
@end defun
@defun emms-cue-previous
Play previous track from .cue file
@end defun



@c -------------------------------------------------------------------
@node Bookmarks
@chapter Bookmarks

Emms can save a ``temporal bookmark'' in a media file via
emms-bookmarks. The file @file{emms-bookmarks.el} provides the package
emms-bookmarks.

While some media is playing, invoking @kbd{M-x emms-bookmarks-add}
will first pause the playback and then prompt for a name describing
the bookmark. Tracks can have multiple bookmarks associated with them.

To jump to the next and previous bookmarks in the current track invoke
@kbd{M-x emms-bookmarks-next} and @kbd{M-x emms-bookmarks-prev}
respectively.

To clear all of the bookmarks for the current track invoke @kbd{M-x
emms-bookmarks-clear}.


@c -------------------------------------------------------------------
@node Managing Playlists
@chapter Managing Playlists

Emms can have multiple playlists, since a playlist is just another
buffer with a list of tracks. You can manage multiple playlists using
`emms-metaplaylist-mode', provided by the file
@file{emms-metaplaylist-mode}.

Start the playlist manager with @kbd{M-x
emms-metaplaylist-mode-go}. The playlist manager will list the
playlists and mark the current one. The following commands are
available:

@table @kbd

@item RET
@kindex RET
@findex emms-metaplaylist-mode-goto-current
Make the buffer at point the Emms playlist buffer and switch to it.

+@item V
@kindex v
@findex emms-metaplaylist-mode-goto
Visit the playlist at point.

@item SPC
@kindex SPC
@findex emms-metaplaylist-mode-set-active
Make the buffer at point the Emms playlist buffer (but do not switch
to it).

@item n
@kindex n
@findex next-line
Move point to the next playlist.

@item p
@kindex p
@findex previous-line
Move point to the previous playlist.

@item g
@kindex g
@findex emms-metaplaylist-mode-update
Update the playlist manager buffer.

@item C
@kindex C
@findex emms-metaplaylist-mode-new-buffer
Create a new Emms playlist buffer.

@item C-k
@kindex C-k
@findex emms-metaplaylist-mode-kill-buffer
Kill the Emms playlist buffer at point.

@item c
@kindex c
@findex emms-metaplaylist-mode-center-current
Move point to the current playlist buffer.

@item q
@kindex q
@findex kill-this-buffer
Kill the playlist manager.

@end table


@c -------------------------------------------------------------------
@node GNU FM
@chapter GNU FM

@cindex GNU FM

@url{https://www.gnu.org/software/gnufm/, GNU FM} is free software for
running music community websites. It was created for the music
community site, @url{http://libre.fm/, Libre.fm}.

Emms can send track information, and stream music from GNU FM servers
using @file{emms-librefm-scrobbler.el} and
@file{emms-librefm-stream.el}, respectively.

Emms is configured by default to use @url{http://libre.fm/, Libre.fm},
but can work with any GNU FM server by configuring the variable
@var{emms-librefm-scrobbler-handshake-url} to the URL of the GNU FM
server.

The recommended way of providing your credentials to the GNU FM server
is by using an authinfo file.  Add authentication to your auth-info
file, typically @file{~/.authinfo.gpg}, as:
@smallexample
machine libre.fm login USERNAME password PASSWORD
@end smallexample
If you are using some other server than libre.fm, change
``@samp{libre.fm}'' to match
@var{emms-librefm-scrobbler-handshake-url}.

Alternatively, you can save the password in plaintext in your init-file
by setting these variables:

@lisp
(setq emms-librefm-scrobbler-username "USERNAME"
      emms-librefm-scrobbler-password "PASSWORD")
@end lisp

@menu
* Uploading Track Information:: How to submit listened track information.
* GNU FM Streaming:: Streaming music from a GNU FM server.
@end menu



@node Uploading Track Information
@section Uploading Track Information

GNU FM servers, such as Libre.fm can optionally store a user's
listening habits using information sent to the website's server from
the Emms. By utilizing the records of users' listening habits, the
website aims to be able to recommend music to users by analyzing their
musical taste.

Load the feature into Emms with:

@lisp
(require 'emms-librefm-scrobbler)
@end lisp

This feature can also be enabled via @xref{Setup}, in the `emms-all'
setup level.

Enable uploading the details of the tracks Emms plays to the GNU FM
server with @kbd{emms-librefm-scrobbler-enable}. The track's details
will be uploaded to the server when the track's playback ends. You can
disable this behavior with @kbd{emms-librefm-scrobbler-disable}.




@node GNU FM Streaming
@section GNU FM Streaming

If the GNU FM server provides a streaming music service you can take
advantage of it by loading:

@lisp
(require 'emms-librefm-stream)
@end lisp

This feature can also be enabled via @xref{Setup}, in the `emms-all'
setup level.

Then invoke @kbd{emms-librefm-stream} and enter the URL of the station
you wish to listen to, for example ``librefm://globaltags/Classical''.

@c -------------------------------------------------------------------
@node Listenbrainz
@chapter Listenbrainz

@cindex Listenbrainz

Listenbrainz offers an alternative store of listening habits
using information sent by the Emms.

To use this service, you will need to obtain a user token
from @url{https://listenbrainz.org/settings/}.  You
should store this token in @file{ ~/.authinfo.gpg} or an
equivalent file understood by auth-source with a line like
this:

@smallexample
machine api.listenbrainz.org password 0abc1de2-245-67fa-8906b-bc123d4dbdaa
@end smallexample

Alternatively, you can store the token in plain-text in your
init file by setting the variable
@kbd{emms-listenbrainz-scrobbler-token}:

@lisp
(setq emms-listenbrainz-scrobbler-token "0abc1de2-245-67fa-8906b-bc123d4dbdaa")
@end lisp

Once this is done, you can load the feature with

@lisp
(require 'emms-listenbrainz-scrobbler)
@end lisp

Enable uploading the details of the tracks Emms plays to the listenbrainz
server with @kbd{emms-listenbrainz-scrobbler-enable}. The track's details
will be uploaded to the server when the track's playback ends. You can
disable this behavior with @kbd{emms-listenbrainz-scrobbler-disable}.

@c -------------------------------------------------------------------
@node D-Bus
@chapter D-Bus

@cindex D-Bus

Emms can provide an MPRIS interface which allows it to be
controlled over D-Bus.

To enable this, first load the feature:

@lisp
(require 'emms-mpris)
@end lisp


and then turn it on with @kbd{emms-mpris-enable}.  You can
turn it off with @kbd{emms-mpris-disable}.

At present, the Emms implementation of the @url{
https://specifications.freedesktop.org/mpris-spec/latest/index.html,
MPRIS specification} is not complete: changing the volume
is not currently supported.


@c including the relevant licenses
@include gpl.texi
@include fdl.texi



@node Concept Index
@unnumbered Concept Index
@printindex cp



@node Function Index
@unnumbered Function Index
@printindex fn



@node Variable Index
@unnumbered Variable Index
@printindex vr



@node Keybinding Index
@unnumbered Keybinding Index
@printindex ky

@bye
